; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\STM32L152D-EVAL\usb_core.o --asm_dir=.\STM32L152D-EVAL\ --list_dir=.\STM32L152D-EVAL\ --depend=.\STM32L152D-EVAL\usb_core.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152D_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL ..\..\..\Libraries\STM32_USB-FS-Device_Driver\src\usb_core.c]
                          THUMB

                          AREA ||i.DataStageIn||, CODE, READONLY, ALIGN=2

                  DataStageIn PROC
;;;512    *******************************************************************************/
;;;513    void DataStageIn(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;514    {
;;;515      ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
000004  f8df909c          LDR      r9,|L1.164|
;;;516      uint32_t save_wLength = pEPinfo->Usb_wLength;
;;;517      uint32_t ControlState = pInformation->ControlState;
;;;518    
;;;519      uint8_t *DataBuffer;
;;;520      uint32_t Length;
;;;521    
;;;522      if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
;;;523      {
;;;524        if(Data_Mul_MaxPacketSize == TRUE)
;;;525        {
;;;526          /* No more data to send and empty packet */
;;;527          Send0LengthData();
000008  f8df809c          LDR      r8,|L1.168|
00000c  f04f0a30          MOV      r10,#0x30
000010  f8d91000          LDR      r1,[r9,#0]            ;515  ; pInformation
000014  f1010510          ADD      r5,r1,#0x10           ;515
000018  8a08              LDRH     r0,[r1,#0x10]         ;516
00001a  7a0e              LDRB     r6,[r1,#8]            ;517
00001c  b908              CBNZ     r0,|L1.34|
00001e  2e04              CMP      r6,#4                 ;522
000020  d004              BEQ      |L1.44|
                  |L1.34|
;;;528          ControlState = LAST_IN_DATA;
;;;529          Data_Mul_MaxPacketSize = FALSE;
;;;530        }
;;;531        else 
;;;532        {
;;;533          /* No more data to send so STALL the TX Status*/
;;;534          ControlState = WAIT_STATUS_OUT;
;;;535    
;;;536        #ifdef STM32F10X_CL      
;;;537          PCD_EP_Read (ENDP0, 0, 0);
;;;538        #endif  /* STM32F10X_CL */ 
;;;539        
;;;540        #ifndef STM32F10X_CL 
;;;541          vSetEPTxStatus(EP_TX_STALL);
;;;542        #endif  /* STM32F10X_CL */ 
;;;543        }
;;;544        
;;;545        goto Expect_Status_Out;
;;;546      }
;;;547    
;;;548      Length = pEPinfo->PacketSize;
000022  88ac              LDRH     r4,[r5,#4]
;;;549      ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
000024  42a0              CMP      r0,r4
000026  d816              BHI      |L1.86|
000028  2604              MOVS     r6,#4
00002a  e015              B        |L1.88|
                  |L1.44|
00002c  491f              LDR      r1,|L1.172|
00002e  7808              LDRB     r0,[r1,#0]            ;524  ; Data_Mul_MaxPacketSize
000030  2801              CMP      r0,#1                 ;524
000032  d004              BEQ      |L1.62|
000034  2607              MOVS     r6,#7                 ;534
000036  2110              MOVS     r1,#0x10              ;541
000038  f8a81000          STRH     r1,[r8,#0]            ;541
00003c  e02c              B        |L1.152|
                  |L1.62|
00003e  4a1c              LDR      r2,|L1.176|
000040  2000              MOVS     r0,#0                 ;527
000042  6812              LDR      r2,[r2,#0]            ;527
000044  4b1b              LDR      r3,|L1.180|
000046  b292              UXTH     r2,r2                 ;527
000048  eb030242          ADD      r2,r3,r2,LSL #1       ;527
00004c  6050              STR      r0,[r2,#4]            ;527
00004e  f8a8a000          STRH     r10,[r8,#0]           ;527
000052  7008              STRB     r0,[r1,#0]            ;529
000054  e020              B        |L1.152|
                  |L1.86|
000056  2602              MOVS     r6,#2
                  |L1.88|
;;;550    
;;;551      if (Length > save_wLength)
000058  4284              CMP      r4,r0
00005a  d900              BLS      |L1.94|
;;;552      {
;;;553        Length = save_wLength;
00005c  4604              MOV      r4,r0
                  |L1.94|
;;;554      }
;;;555    
;;;556      DataBuffer = (*pEPinfo->CopyData)(Length);
00005e  b2a0              UXTH     r0,r4
000060  68a9              LDR      r1,[r5,#8]
000062  4607              MOV      r7,r0
000064  4788              BLX      r1
000066  4683              MOV      r11,r0
;;;557    
;;;558    #ifdef STM32F10X_CL
;;;559      PCD_EP_Write (ENDP0, DataBuffer, Length);
;;;560    #else   
;;;561      UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       GetEPTxAddr
00006e  4601              MOV      r1,r0
000070  463a              MOV      r2,r7
000072  4658              MOV      r0,r11
000074  f7fffffe          BL       UserToPMABufferCopy
000078  4639              MOV      r1,r7
;;;562    #endif /* STM32F10X_CL */ 
;;;563    
;;;564      SetEPTxCount(ENDP0, Length);
00007a  2000              MOVS     r0,#0
00007c  f7fffffe          BL       SetEPTxCount
;;;565    
;;;566      pEPinfo->Usb_wLength -= Length;
000080  8828              LDRH     r0,[r5,#0]
000082  1b00              SUBS     r0,r0,r4
000084  8028              STRH     r0,[r5,#0]
;;;567      pEPinfo->Usb_wOffset += Length;
000086  8868              LDRH     r0,[r5,#2]
000088  4420              ADD      r0,r0,r4
00008a  8068              STRH     r0,[r5,#2]
;;;568      vSetEPTxStatus(EP_TX_VALID);
00008c  f8a8a000          STRH     r10,[r8,#0]
;;;569    
;;;570      USB_StatusOut();/* Expect the host to abort the data IN stage */
000090  4909              LDR      r1,|L1.184|
000092  f44f5040          MOV      r0,#0x3000
000096  8008              STRH     r0,[r1,#0]
                  |L1.152|
;;;571    
;;;572    Expect_Status_Out:
;;;573      pInformation->ControlState = ControlState;
000098  f8d90000          LDR      r0,[r9,#0]  ; pInformation
00009c  7206              STRB     r6,[r0,#8]
;;;574    }
00009e  e8bd9ff0          POP      {r4-r12,pc}
;;;575    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L1.164|
                          DCD      pInformation
                  |L1.168|
                          DCD      SaveTState
                  |L1.172|
                          DCD      ||.data||
                  |L1.176|
                          DCD      0x40005c50
                  |L1.180|
                          DCD      0x40006000
                  |L1.184|
                          DCD      SaveRState

                          AREA ||i.DataStageOut||, CODE, READONLY, ALIGN=2

                  DataStageOut PROC
;;;451    *******************************************************************************/
;;;452    void DataStageOut(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;453    {
;;;454      ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
000004  4e23              LDR      r6,|L2.148|
;;;455      uint32_t save_rLength;
;;;456    
;;;457      save_rLength = pEPinfo->Usb_rLength;
;;;458    
;;;459      if (pEPinfo->CopyData && save_rLength)
;;;460      {
;;;461        uint8_t *Buffer;
;;;462        uint32_t Length;
;;;463    
;;;464        Length = pEPinfo->PacketSize;
;;;465        if (Length > save_rLength)
;;;466        {
;;;467          Length = save_rLength;
;;;468        }
;;;469    
;;;470        Buffer = (*pEPinfo->CopyData)(Length);
;;;471        pEPinfo->Usb_rLength -= Length;
;;;472        pEPinfo->Usb_rOffset += Length;
;;;473    
;;;474      #ifdef STM32F10X_CL  
;;;475        PCD_EP_Read(ENDP0, Buffer, Length); 
;;;476      #else  
;;;477        PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
;;;478      #endif  /* STM32F10X_CL */
;;;479      }
;;;480    
;;;481      if (pEPinfo->Usb_rLength != 0)
;;;482      {
;;;483        vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
;;;484        SetEPTxCount(ENDP0, 0);
;;;485        vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
000006  f8df9090          LDR      r9,|L2.152|
00000a  f04f0830          MOV      r8,#0x30
00000e  6834              LDR      r4,[r6,#0]            ;457  ; pInformation
000010  f8340f10          LDRH     r0,[r4,#0x10]!        ;457
000014  68a1              LDR      r1,[r4,#8]            ;459
000016  b1b1              CBZ      r1,|L2.70|
000018  b308              CBZ      r0,|L2.94|
00001a  88a5              LDRH     r5,[r4,#4]            ;464
00001c  4285              CMP      r5,r0                 ;465
00001e  d900              BLS      |L2.34|
000020  4605              MOV      r5,r0                 ;467
                  |L2.34|
000022  b2a8              UXTH     r0,r5                 ;470
000024  4607              MOV      r7,r0                 ;470
000026  4788              BLX      r1                    ;470
000028  4682              MOV      r10,r0                ;470
00002a  8820              LDRH     r0,[r4,#0]            ;471
00002c  1b40              SUBS     r0,r0,r5              ;471
00002e  8020              STRH     r0,[r4,#0]            ;471
000030  8860              LDRH     r0,[r4,#2]            ;472
000032  4428              ADD      r0,r0,r5              ;472
000034  8060              STRH     r0,[r4,#2]            ;472
000036  2000              MOVS     r0,#0                 ;477
000038  f7fffffe          BL       GetEPRxAddr
00003c  4601              MOV      r1,r0                 ;477
00003e  463a              MOV      r2,r7                 ;477
000040  4650              MOV      r0,r10                ;477
000042  f7fffffe          BL       PMAToUserBufferCopy
                  |L2.70|
000046  8820              LDRH     r0,[r4,#0]            ;481
000048  b148              CBZ      r0,|L2.94|
00004a  4914              LDR      r1,|L2.156|
00004c  f44f5040          MOV      r0,#0x3000            ;483
000050  8008              STRH     r0,[r1,#0]            ;483
000052  2100              MOVS     r1,#0                 ;484
000054  4608              MOV      r0,r1                 ;484
000056  f7fffffe          BL       SetEPTxCount
00005a  f8a98000          STRH     r8,[r9,#0]
                  |L2.94|
;;;486      }
;;;487      /* Set the next State*/
;;;488      if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
00005e  8820              LDRH     r0,[r4,#0]
000060  88a1              LDRH     r1,[r4,#4]
000062  4288              CMP      r0,r1
000064  d301              BCC      |L2.106|
;;;489      {
;;;490        pInformation->ControlState = OUT_DATA;
000066  2003              MOVS     r0,#3
000068  e001              B        |L2.110|
                  |L2.106|
;;;491      }
;;;492      else
;;;493      {
;;;494        if (pEPinfo->Usb_rLength > 0)
00006a  b120              CBZ      r0,|L2.118|
;;;495        {
;;;496          pInformation->ControlState = LAST_OUT_DATA;
00006c  2005              MOVS     r0,#5
                  |L2.110|
00006e  6831              LDR      r1,[r6,#0]            ;490  ; pInformation
000070  7208              STRB     r0,[r1,#8]            ;490
                  |L2.114|
;;;497        }
;;;498        else if (pEPinfo->Usb_rLength == 0)
;;;499        {
;;;500          pInformation->ControlState = WAIT_STATUS_IN;
;;;501          USB_StatusIn();
;;;502        }
;;;503      }
;;;504    }
000072  e8bd87f0          POP      {r4-r10,pc}
                  |L2.118|
000076  6831              LDR      r1,[r6,#0]            ;500  ; pInformation
000078  2006              MOVS     r0,#6                 ;500
00007a  7208              STRB     r0,[r1,#8]            ;500
00007c  4908              LDR      r1,|L2.160|
00007e  2000              MOVS     r0,#0                 ;501
000080  6809              LDR      r1,[r1,#0]            ;501
000082  4a08              LDR      r2,|L2.164|
000084  b289              UXTH     r1,r1                 ;501
000086  eb020141          ADD      r1,r2,r1,LSL #1       ;501
00008a  6048              STR      r0,[r1,#4]            ;501
00008c  f8a98000          STRH     r8,[r9,#0]            ;501
000090  e7ef              B        |L2.114|
;;;505    
                          ENDP

000092  0000              DCW      0x0000
                  |L2.148|
                          DCD      pInformation
                  |L2.152|
                          DCD      SaveTState
                  |L2.156|
                          DCD      SaveRState
                  |L2.160|
                          DCD      0x40005c50
                  |L2.164|
                          DCD      0x40006000

                          AREA ||i.Data_Setup0||, CODE, READONLY, ALIGN=2

                  Data_Setup0 PROC
;;;709    *******************************************************************************/
;;;710    void Data_Setup0(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;711    {
;;;712      uint8_t *(*CopyRoutine)(uint16_t);
;;;713      RESULT Result;
;;;714      uint32_t Request_No = pInformation->USBbRequest;
000004  4c5c              LDR      r4,|L3.376|
;;;715    
;;;716      uint32_t Related_Endpoint, Reserved;
;;;717      uint32_t wOffset, Status;
;;;718    
;;;719    
;;;720    
;;;721      CopyRoutine = NULL;
;;;722      wOffset = 0;
;;;723    
;;;724      /*GET DESCRIPTOR*/
;;;725      if (Request_No == GET_DESCRIPTOR)
;;;726      {
;;;727        if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
;;;728        {
;;;729          uint8_t wValue1 = pInformation->USBwValue1;
;;;730          if (wValue1 == DEVICE_DESCRIPTOR)
;;;731          {
;;;732            CopyRoutine = pProperty->GetDeviceDescriptor;
000006  4d5d              LDR      r5,|L3.380|
;;;733          }
;;;734          else if (wValue1 == CONFIG_DESCRIPTOR)
;;;735          {
;;;736            CopyRoutine = pProperty->GetConfigDescriptor;
;;;737          }
;;;738          else if (wValue1 == STRING_DESCRIPTOR)
;;;739          {
;;;740            CopyRoutine = pProperty->GetStringDescriptor;
;;;741          }  /* End of GET_DESCRIPTOR */
;;;742        }
;;;743      }
;;;744    
;;;745      /*GET STATUS*/
;;;746      else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
;;;747               && (pInformation->USBwLength == 0x0002)
;;;748               && (pInformation->USBwIndex1 == 0))
;;;749      {
;;;750        /* GET STATUS for Device*/
;;;751        if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
;;;752            && (pInformation->USBwIndex == 0))
;;;753        {
;;;754          CopyRoutine = Standard_GetStatus;
;;;755        }
;;;756    
;;;757        /* GET STATUS for Interface*/
;;;758        else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
;;;759        {
;;;760          if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
;;;761              && (pInformation->Current_Configuration != 0))
;;;762          {
;;;763            CopyRoutine = Standard_GetStatus;
;;;764          }
;;;765        }
;;;766    
;;;767        /* GET STATUS for EndPoint*/
;;;768        else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
;;;769        {
;;;770          Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
;;;771          Reserved = pInformation->USBwIndex0 & 0x70;
;;;772    
;;;773          if (ValBit(pInformation->USBwIndex0, 7))
;;;774          {
;;;775            /*Get Status of endpoint & stall the request if the related_ENdpoint
;;;776            is Disabled*/
;;;777            Status = _GetEPTxStatus(Related_Endpoint);
;;;778          }
;;;779          else
;;;780          {
;;;781            Status = _GetEPRxStatus(Related_Endpoint);
;;;782          }
;;;783    
;;;784          if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
;;;785              && (Status != 0))
;;;786          {
;;;787            CopyRoutine = Standard_GetStatus;
;;;788          }
;;;789        }
;;;790    
;;;791      }
;;;792    
;;;793      /*GET CONFIGURATION*/
;;;794      else if (Request_No == GET_CONFIGURATION)
;;;795      {
;;;796        if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
;;;797        {
;;;798          CopyRoutine = Standard_GetConfiguration;
;;;799        }
;;;800      }
;;;801      /*GET INTERFACE*/
;;;802      else if (Request_No == GET_INTERFACE)
;;;803      {
;;;804        if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
;;;805            && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
;;;806            && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
;;;807            && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
;;;808        {
;;;809          CopyRoutine = Standard_GetInterface;
;;;810        }
;;;811    
;;;812      }
;;;813      
;;;814      if (CopyRoutine)
;;;815      {
;;;816        pInformation->Ctrl_Info.Usb_wOffset = wOffset;
;;;817        pInformation->Ctrl_Info.CopyData = CopyRoutine;
;;;818        /* sb in the original the cast to word was directly */
;;;819        /* now the cast is made step by step */
;;;820        (*CopyRoutine)(0);
;;;821        Result = USB_SUCCESS;
;;;822      }
;;;823      else
;;;824      {
;;;825        Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
;;;826        if (Result == USB_NOT_READY)
;;;827        {
;;;828          pInformation->ControlState = PAUSE;
000008  2609              MOVS     r6,#9
00000a  6820              LDR      r0,[r4,#0]            ;714  ; pInformation
00000c  2700              MOVS     r7,#0                 ;721
00000e  6829              LDR      r1,[r5,#0]            ;725
000010  7842              LDRB     r2,[r0,#1]            ;714
000012  2a06              CMP      r2,#6                 ;725
000014  d005              BEQ      |L3.34|
000016  b1aa              CBZ      r2,|L3.68|
000018  2a08              CMP      r2,#8                 ;794
00001a  d04b              BEQ      |L3.180|
00001c  2a0a              CMP      r2,#0xa               ;802
00001e  d04e              BEQ      |L3.190|
000020  e069              B        |L3.246|
                  |L3.34|
000022  7802              LDRB     r2,[r0,#0]            ;727
000024  0652              LSLS     r2,r2,#25             ;727
000026  d166              BNE      |L3.246|
000028  7880              LDRB     r0,[r0,#2]            ;729
00002a  2801              CMP      r0,#1                 ;730
00002c  d004              BEQ      |L3.56|
00002e  2802              CMP      r0,#2                 ;734
000030  d004              BEQ      |L3.60|
000032  2803              CMP      r0,#3                 ;738
000034  d004              BEQ      |L3.64|
000036  e05e              B        |L3.246|
                  |L3.56|
000038  69c9              LDR      r1,[r1,#0x1c]         ;732
00003a  e054              B        |L3.230|
                  |L3.60|
00003c  6a09              LDR      r1,[r1,#0x20]         ;736
00003e  e052              B        |L3.230|
                  |L3.64|
000040  6a49              LDR      r1,[r1,#0x24]         ;740
000042  e050              B        |L3.230|
                  |L3.68|
000044  8842              LDRH     r2,[r0,#2]            ;746
000046  bba2              CBNZ     r2,|L3.178|
000048  88c2              LDRH     r2,[r0,#6]            ;747
00004a  2a02              CMP      r2,#2                 ;747
00004c  d153              BNE      |L3.246|
00004e  7902              LDRB     r2,[r0,#4]            ;748
000050  bb7a              CBNZ     r2,|L3.178|
000052  7802              LDRB     r2,[r0,#0]            ;751
000054  0653              LSLS     r3,r2,#25             ;751
000056  d101              BNE      |L3.92|
000058  8883              LDRH     r3,[r0,#4]            ;752
00005a  b133              CBZ      r3,|L3.106|
                  |L3.92|
00005c  f002027f          AND      r2,r2,#0x7f           ;758
000060  2a01              CMP      r2,#1                 ;758
000062  d004              BEQ      |L3.110|
000064  2a02              CMP      r2,#2                 ;768
000066  d00c              BEQ      |L3.130|
000068  e045              B        |L3.246|
                  |L3.106|
00006a  4945              LDR      r1,|L3.384|
00006c  e03b              B        |L3.230|
                  |L3.110|
00006e  698a              LDR      r2,[r1,#0x18]         ;760
000070  7940              LDRB     r0,[r0,#5]            ;760
000072  2100              MOVS     r1,#0                 ;760
000074  4790              BLX      r2                    ;760
000076  b9e0              CBNZ     r0,|L3.178|
000078  6820              LDR      r0,[r4,#0]            ;761  ; pInformation
00007a  7a80              LDRB     r0,[r0,#0xa]          ;761
00007c  2800              CMP      r0,#0                 ;761
00007e  d1f4              BNE      |L3.106|
000080  e039              B        |L3.246|
                  |L3.130|
000082  7941              LDRB     r1,[r0,#5]            ;770
000084  f001000f          AND      r0,r1,#0xf            ;770
000088  f0010270          AND      r2,r1,#0x70           ;771
00008c  060b              LSLS     r3,r1,#24             ;773
00008e  493d              LDR      r1,|L3.388|
000090  f8511020          LDR      r1,[r1,r0,LSL #2]     ;781
000094  d503              BPL      |L3.158|
000096  f3c11101          UBFX     r1,r1,#4,#2           ;777
00009a  0109              LSLS     r1,r1,#4              ;777
00009c  e002              B        |L3.164|
                  |L3.158|
00009e  f3c13101          UBFX     r1,r1,#12,#2          ;781
0000a2  0309              LSLS     r1,r1,#12             ;781
                  |L3.164|
0000a4  4b38              LDR      r3,|L3.392|
0000a6  781b              LDRB     r3,[r3,#0]            ;784  ; Device_Table
0000a8  4283              CMP      r3,r0                 ;784
0000aa  d924              BLS      |L3.246|
0000ac  b90a              CBNZ     r2,|L3.178|
0000ae  2900              CMP      r1,#0                 ;785
0000b0  d1db              BNE      |L3.106|
                  |L3.178|
0000b2  e020              B        |L3.246|
                  |L3.180|
0000b4  7800              LDRB     r0,[r0,#0]            ;796
0000b6  0640              LSLS     r0,r0,#25             ;796
0000b8  d11d              BNE      |L3.246|
0000ba  4934              LDR      r1,|L3.396|
0000bc  e013              B        |L3.230|
                  |L3.190|
0000be  7802              LDRB     r2,[r0,#0]            ;804
0000c0  f002027f          AND      r2,r2,#0x7f           ;804
0000c4  2a01              CMP      r2,#1                 ;804
0000c6  d116              BNE      |L3.246|
0000c8  7a82              LDRB     r2,[r0,#0xa]          ;805
0000ca  b1a2              CBZ      r2,|L3.246|
0000cc  8842              LDRH     r2,[r0,#2]            ;805
0000ce  b992              CBNZ     r2,|L3.246|
0000d0  7902              LDRB     r2,[r0,#4]            ;806
0000d2  b982              CBNZ     r2,|L3.246|
0000d4  88c2              LDRH     r2,[r0,#6]            ;806
0000d6  2a01              CMP      r2,#1                 ;806
0000d8  d10d              BNE      |L3.246|
0000da  698a              LDR      r2,[r1,#0x18]         ;807
0000dc  7940              LDRB     r0,[r0,#5]            ;807
0000de  2100              MOVS     r1,#0                 ;807
0000e0  4790              BLX      r2                    ;807
0000e2  b940              CBNZ     r0,|L3.246|
0000e4  492a              LDR      r1,|L3.400|
                  |L3.230|
0000e6  b131              CBZ      r1,|L3.246|
0000e8  6820              LDR      r0,[r4,#0]            ;816  ; pInformation
0000ea  8247              STRH     r7,[r0,#0x12]         ;816
0000ec  6181              STR      r1,[r0,#0x18]         ;820
0000ee  2000              MOVS     r0,#0                 ;820
0000f0  4788              BLX      r1                    ;820
0000f2  2000              MOVS     r0,#0                 ;821
0000f4  e006              B        |L3.260|
                  |L3.246|
0000f6  6829              LDR      r1,[r5,#0]            ;825  ; pProperty
0000f8  6820              LDR      r0,[r4,#0]            ;825  ; pInformation
0000fa  6909              LDR      r1,[r1,#0x10]         ;825
0000fc  7840              LDRB     r0,[r0,#1]            ;825
0000fe  4788              BLX      r1                    ;825
000100  2803              CMP      r0,#3                 ;826
000102  d008              BEQ      |L3.278|
                  |L3.260|
;;;829          return;
;;;830        }
;;;831      }
;;;832    
;;;833      if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
000104  6821              LDR      r1,[r4,#0]  ; pInformation
000106  8a0a              LDRH     r2,[r1,#0x10]
000108  f5a2437f          SUB      r3,r2,#0xff00
00010c  3bff              SUBS     r3,r3,#0xff
00010e  d105              BNE      |L3.284|
;;;834      {
;;;835        /* Data is not ready, wait it */
;;;836        pInformation->ControlState = PAUSE;
000110  720e              STRB     r6,[r1,#8]
                  |L3.274|
;;;837        return;
;;;838      }
;;;839      if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
;;;840      {
;;;841        /* Unsupported request */
;;;842        pInformation->ControlState = STALLED;
;;;843        return;
;;;844      }
;;;845    
;;;846    
;;;847      if (ValBit(pInformation->USBbmRequestType, 7))
;;;848      {
;;;849        /* Device ==> Host */
;;;850        __IO uint32_t wLength = pInformation->USBwLength;
;;;851         
;;;852        /* Restrict the data length to be the one host asks for */
;;;853        if (pInformation->Ctrl_Info.Usb_wLength > wLength)
;;;854        {
;;;855          pInformation->Ctrl_Info.Usb_wLength = wLength;
;;;856        }
;;;857        
;;;858        else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
;;;859        {
;;;860          if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
;;;861          {
;;;862            Data_Mul_MaxPacketSize = FALSE;
;;;863          }
;;;864          else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
;;;865          {
;;;866            Data_Mul_MaxPacketSize = TRUE;
;;;867          }
;;;868        }   
;;;869    
;;;870        pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
;;;871        DataStageIn();
;;;872      }
;;;873      else
;;;874      {
;;;875        pInformation->ControlState = OUT_DATA;
;;;876        vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
;;;877      }
;;;878    
;;;879      return;
;;;880    }
000112  e8bd81f0          POP      {r4-r8,pc}
                  |L3.278|
000116  6820              LDR      r0,[r4,#0]            ;828  ; pInformation
000118  7206              STRB     r6,[r0,#8]            ;828
00011a  e7fa              B        |L3.274|
                  |L3.284|
00011c  2802              CMP      r0,#2                 ;839
00011e  d008              BEQ      |L3.306|
000120  b13a              CBZ      r2,|L3.306|
000122  7808              LDRB     r0,[r1,#0]            ;847
000124  0600              LSLS     r0,r0,#24             ;847
000126  d520              BPL      |L3.362|
000128  88c8              LDRH     r0,[r1,#6]            ;850
00012a  4282              CMP      r2,r0                 ;853
00012c  d905              BLS      |L3.314|
00012e  8208              STRH     r0,[r1,#0x10]         ;855
000130  e013              B        |L3.346|
                  |L3.306|
000132  f04f0008          MOV      r0,#8                 ;842
000136  7208              STRB     r0,[r1,#8]            ;842
000138  e7eb              B        |L3.274|
                  |L3.314|
00013a  d20e              BCS      |L3.346|
00013c  6828              LDR      r0,[r5,#0]            ;860  ; pProperty
00013e  4b15              LDR      r3,|L3.404|
000140  f890002c          LDRB     r0,[r0,#0x2c]         ;860
000144  4282              CMP      r2,r0                 ;860
000146  d201              BCS      |L3.332|
000148  701f              STRB     r7,[r3,#0]            ;862
00014a  e006              B        |L3.346|
                  |L3.332|
00014c  fbb2f4f0          UDIV     r4,r2,r0              ;864
000150  fb002014          MLS      r0,r0,r4,r2           ;864
000154  b908              CBNZ     r0,|L3.346|
000156  2001              MOVS     r0,#1                 ;866
000158  7018              STRB     r0,[r3,#0]            ;866
                  |L3.346|
00015a  6828              LDR      r0,[r5,#0]            ;870  ; pProperty
00015c  f890002c          LDRB     r0,[r0,#0x2c]         ;870
000160  8288              STRH     r0,[r1,#0x14]         ;870
000162  e8bd41f0          POP      {r4-r8,lr}            ;871
000166  f7ffbffe          B.W      DataStageIn
                  |L3.362|
00016a  2003              MOVS     r0,#3                 ;875
00016c  7208              STRB     r0,[r1,#8]            ;875
00016e  490a              LDR      r1,|L3.408|
000170  0300              LSLS     r0,r0,#12             ;876
000172  8008              STRH     r0,[r1,#0]            ;876
000174  e7cd              B        |L3.274|
;;;881    
                          ENDP

000176  0000              DCW      0x0000
                  |L3.376|
                          DCD      pInformation
                  |L3.380|
                          DCD      pProperty
                  |L3.384|
                          DCD      Standard_GetStatus
                  |L3.388|
                          DCD      0x40005c00
                  |L3.392|
                          DCD      Device_Table
                  |L3.396|
                          DCD      Standard_GetConfiguration
                  |L3.400|
                          DCD      Standard_GetInterface
                  |L3.404|
                          DCD      ||.data||
                  |L3.408|
                          DCD      SaveRState

                          AREA ||i.In0_Process||, CODE, READONLY, ALIGN=2

                  In0_Process PROC
;;;942    *******************************************************************************/
;;;943    uint8_t In0_Process(void)
000000  b510              PUSH     {r4,lr}
;;;944    {
;;;945      uint32_t ControlState = pInformation->ControlState;
000002  4c13              LDR      r4,|L4.80|
000004  6820              LDR      r0,[r4,#0]  ; pInformation
000006  7a01              LDRB     r1,[r0,#8]
;;;946    
;;;947      if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
000008  2902              CMP      r1,#2
00000a  d004              BEQ      |L4.22|
00000c  2904              CMP      r1,#4
00000e  d002              BEQ      |L4.22|
;;;948      {
;;;949        DataStageIn();
;;;950        /* ControlState may be changed outside the function */
;;;951        ControlState = pInformation->ControlState;
;;;952      }
;;;953    
;;;954      else if (ControlState == WAIT_STATUS_IN)
000010  2906              CMP      r1,#6
000012  d005              BEQ      |L4.32|
000014  e015              B        |L4.66|
                  |L4.22|
000016  f7fffffe          BL       DataStageIn
00001a  6820              LDR      r0,[r4,#0]            ;951  ; pInformation
00001c  7a00              LDRB     r0,[r0,#8]            ;951
00001e  e011              B        |L4.68|
                  |L4.32|
;;;955      {
;;;956        if ((pInformation->USBbRequest == SET_ADDRESS) &&
000020  7841              LDRB     r1,[r0,#1]
000022  2905              CMP      r1,#5
000024  d109              BNE      |L4.58|
;;;957            (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
000026  7801              LDRB     r1,[r0,#0]
000028  0649              LSLS     r1,r1,#25
00002a  d106              BNE      |L4.58|
;;;958        {
;;;959          SetDeviceAddress(pInformation->USBwValue0);
00002c  78c0              LDRB     r0,[r0,#3]
00002e  f7fffffe          BL       SetDeviceAddress
;;;960          pUser_Standard_Requests->User_SetDeviceAddress();
000032  4808              LDR      r0,|L4.84|
000034  6800              LDR      r0,[r0,#0]  ; pUser_Standard_Requests
000036  6a00              LDR      r0,[r0,#0x20]
000038  4780              BLX      r0
                  |L4.58|
;;;961        }
;;;962        (*pProperty->Process_Status_IN)();
00003a  4807              LDR      r0,|L4.88|
00003c  6800              LDR      r0,[r0,#0]  ; pProperty
00003e  6880              LDR      r0,[r0,#8]
000040  4780              BLX      r0
                  |L4.66|
;;;963        ControlState = STALLED;
;;;964      }
;;;965    
;;;966      else
;;;967      {
;;;968        ControlState = STALLED;
000042  2008              MOVS     r0,#8
                  |L4.68|
;;;969      }
;;;970    
;;;971      pInformation->ControlState = ControlState;
000044  6821              LDR      r1,[r4,#0]  ; pInformation
000046  7208              STRB     r0,[r1,#8]
;;;972    
;;;973      return Post0_Process();
000048  e8bd4010          POP      {r4,lr}
00004c  f7ffbffe          B.W      Post0_Process
;;;974    }
;;;975    
                          ENDP

                  |L4.80|
                          DCD      pInformation
                  |L4.84|
                          DCD      pUser_Standard_Requests
                  |L4.88|
                          DCD      pProperty

                          AREA ||i.NOP_Process||, CODE, READONLY, ALIGN=1

                  NOP_Process PROC
;;;1093   *******************************************************************************/
;;;1094   void NOP_Process(void)
000000  4770              BX       lr
;;;1095   {
;;;1096   }
;;;1097   
                          ENDP


                          AREA ||i.NoData_Setup0||, CODE, READONLY, ALIGN=2

                  NoData_Setup0 PROC
;;;582    *******************************************************************************/
;;;583    void NoData_Setup0(void)
000000  b570              PUSH     {r4-r6,lr}
;;;584    {
;;;585      RESULT Result = USB_UNSUPPORT;
;;;586      uint32_t RequestNo = pInformation->USBbRequest;
000002  4d2f              LDR      r5,|L6.192|
000004  6828              LDR      r0,[r5,#0]  ; pInformation
;;;587      uint32_t ControlState;
;;;588    
;;;589      if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
000006  7801              LDRB     r1,[r0,#0]
000008  7844              LDRB     r4,[r0,#1]            ;586
00000a  064a              LSLS     r2,r1,#25
00000c  d006              BEQ      |L6.28|
;;;590      {
;;;591        /* Device Request*/
;;;592        /* SET_CONFIGURATION*/
;;;593        if (RequestNo == SET_CONFIGURATION)
;;;594        {
;;;595          Result = Standard_SetConfiguration();
;;;596        }
;;;597    
;;;598        /*SET ADDRESS*/
;;;599        else if (RequestNo == SET_ADDRESS)
;;;600        {
;;;601          if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
;;;602              || (pInformation->USBwIndex != 0)
;;;603              || (pInformation->Current_Configuration != 0))
;;;604            /* Device Address should be 127 or less*/
;;;605          {
;;;606            ControlState = STALLED;
;;;607            goto exit_NoData_Setup0;
;;;608          }
;;;609          else
;;;610          {
;;;611            Result = USB_SUCCESS;
;;;612    
;;;613          #ifdef STM32F10X_CL
;;;614             SetDeviceAddress(pInformation->USBwValue0);
;;;615          #endif  /* STM32F10X_CL */
;;;616          }
;;;617        }
;;;618        /*SET FEATURE for Device*/
;;;619        else if (RequestNo == SET_FEATURE)
;;;620        {
;;;621          if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP) \
;;;622              && (pInformation->USBwIndex == 0))
;;;623          {
;;;624            Result = Standard_SetDeviceFeature();
;;;625          }
;;;626          else
;;;627          {
;;;628            Result = USB_UNSUPPORT;
;;;629          }
;;;630        }
;;;631        /*Clear FEATURE for Device */
;;;632        else if (RequestNo == CLEAR_FEATURE)
;;;633        {
;;;634          if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
;;;635              && pInformation->USBwIndex == 0
;;;636              && ValBit(pInformation->Current_Feature, 5))
;;;637          {
;;;638            Result = Standard_ClearFeature();
;;;639          }
;;;640          else
;;;641          {
;;;642            Result = USB_UNSUPPORT;
;;;643          }
;;;644        }
;;;645    
;;;646      }
;;;647    
;;;648      /* Interface Request*/
;;;649      else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
00000e  f001007f          AND      r0,r1,#0x7f
000012  2801              CMP      r0,#1
000014  d028              BEQ      |L6.104|
;;;650      {
;;;651        /*SET INTERFACE*/
;;;652        if (RequestNo == SET_INTERFACE)
;;;653        {
;;;654          Result = Standard_SetInterface();
;;;655        }
;;;656      }
;;;657    
;;;658      /* EndPoint Request*/
;;;659      else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
000016  2802              CMP      r0,#2
000018  d02b              BEQ      |L6.114|
00001a  e035              B        |L6.136|
                  |L6.28|
00001c  2c09              CMP      r4,#9                 ;593
00001e  d006              BEQ      |L6.46|
000020  2c05              CMP      r4,#5                 ;599
000022  d007              BEQ      |L6.52|
000024  2c03              CMP      r4,#3                 ;619
000026  d00e              BEQ      |L6.70|
000028  2c01              CMP      r4,#1                 ;632
00002a  d014              BEQ      |L6.86|
00002c  e02c              B        |L6.136|
                  |L6.46|
00002e  f7fffffe          BL       Standard_SetConfiguration
000032  e028              B        |L6.134|
                  |L6.52|
000034  78c1              LDRB     r1,[r0,#3]            ;601
000036  297f              CMP      r1,#0x7f              ;601
000038  d82e              BHI      |L6.152|
00003a  7881              LDRB     r1,[r0,#2]            ;601
00003c  bb61              CBNZ     r1,|L6.152|
00003e  8881              LDRH     r1,[r0,#4]            ;602
000040  bb51              CBNZ     r1,|L6.152|
000042  7a80              LDRB     r0,[r0,#0xa]          ;603
000044  e027              B        |L6.150|
                  |L6.70|
000046  78c1              LDRB     r1,[r0,#3]            ;621
000048  2901              CMP      r1,#1                 ;621
00004a  d11d              BNE      |L6.136|
00004c  8880              LDRH     r0,[r0,#4]            ;622
00004e  b9d8              CBNZ     r0,|L6.136|
000050  f7fffffe          BL       Standard_SetDeviceFeature
000054  e017              B        |L6.134|
                  |L6.86|
000056  78c1              LDRB     r1,[r0,#3]            ;634
000058  2901              CMP      r1,#1                 ;634
00005a  d115              BNE      |L6.136|
00005c  8881              LDRH     r1,[r0,#4]            ;635
00005e  b999              CBNZ     r1,|L6.136|
000060  7a40              LDRB     r0,[r0,#9]            ;636
000062  0680              LSLS     r0,r0,#26             ;636
000064  d40a              BMI      |L6.124|
000066  e00f              B        |L6.136|
                  |L6.104|
000068  2c0b              CMP      r4,#0xb               ;652
00006a  d10d              BNE      |L6.136|
00006c  f7fffffe          BL       Standard_SetInterface
000070  e009              B        |L6.134|
                  |L6.114|
;;;660      {
;;;661        /*CLEAR FEATURE for EndPoint*/
;;;662        if (RequestNo == CLEAR_FEATURE)
000072  2c01              CMP      r4,#1
000074  d002              BEQ      |L6.124|
;;;663        {
;;;664          Result = Standard_ClearFeature();
;;;665        }
;;;666        /* SET FEATURE for EndPoint*/
;;;667        else if (RequestNo == SET_FEATURE)
000076  2c03              CMP      r4,#3
000078  d003              BEQ      |L6.130|
00007a  e005              B        |L6.136|
                  |L6.124|
00007c  f7fffffe          BL       Standard_ClearFeature
000080  e001              B        |L6.134|
                  |L6.130|
;;;668        {
;;;669          Result = Standard_SetEndPointFeature();
000082  f7fffffe          BL       Standard_SetEndPointFeature
                  |L6.134|
;;;670        }
;;;671      }
;;;672      else
;;;673      {
;;;674        Result = USB_UNSUPPORT;
;;;675      }
;;;676    
;;;677    
;;;678      if (Result != USB_SUCCESS)
000086  b158              CBZ      r0,|L6.160|
                  |L6.136|
;;;679      {
;;;680        Result = (*pProperty->Class_NoData_Setup)(RequestNo);
000088  480e              LDR      r0,|L6.196|
00008a  6800              LDR      r0,[r0,#0]  ; pProperty
00008c  6941              LDR      r1,[r0,#0x14]
00008e  b2e0              UXTB     r0,r4
000090  4788              BLX      r1
;;;681        if (Result == USB_NOT_READY)
000092  2803              CMP      r0,#3
000094  d002              BEQ      |L6.156|
                  |L6.150|
;;;682        {
;;;683          ControlState = PAUSE;
;;;684          goto exit_NoData_Setup0;
;;;685        }
;;;686      }
;;;687    
;;;688      if (Result != USB_SUCCESS)
000096  b118              CBZ      r0,|L6.160|
                  |L6.152|
;;;689      {
;;;690        ControlState = STALLED;
000098  2008              MOVS     r0,#8
;;;691        goto exit_NoData_Setup0;
00009a  e00d              B        |L6.184|
                  |L6.156|
00009c  2009              MOVS     r0,#9                 ;683
00009e  e00b              B        |L6.184|
                  |L6.160|
;;;692      }
;;;693    
;;;694      ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
;;;695    
;;;696      USB_StatusIn();
0000a0  4a09              LDR      r2,|L6.200|
0000a2  2006              MOVS     r0,#6                 ;694
0000a4  2100              MOVS     r1,#0
0000a6  6812              LDR      r2,[r2,#0]
0000a8  4b08              LDR      r3,|L6.204|
0000aa  b292              UXTH     r2,r2
0000ac  eb030242          ADD      r2,r3,r2,LSL #1
0000b0  6051              STR      r1,[r2,#4]
0000b2  4a07              LDR      r2,|L6.208|
0000b4  2130              MOVS     r1,#0x30
0000b6  8011              STRH     r1,[r2,#0]
                  |L6.184|
;;;697    
;;;698    exit_NoData_Setup0:
;;;699      pInformation->ControlState = ControlState;
0000b8  6829              LDR      r1,[r5,#0]  ; pInformation
0000ba  7208              STRB     r0,[r1,#8]
;;;700      return;
;;;701    }
0000bc  bd70              POP      {r4-r6,pc}
;;;702    
                          ENDP

0000be  0000              DCW      0x0000
                  |L6.192|
                          DCD      pInformation
                  |L6.196|
                          DCD      pProperty
                  |L6.200|
                          DCD      0x40005c50
                  |L6.204|
                          DCD      0x40006000
                  |L6.208|
                          DCD      SaveTState

                          AREA ||i.Out0_Process||, CODE, READONLY, ALIGN=2

                  Out0_Process PROC
;;;982    *******************************************************************************/
;;;983    uint8_t Out0_Process(void)
000000  b510              PUSH     {r4,lr}
;;;984    {
;;;985      uint32_t ControlState = pInformation->ControlState;
000002  4c0f              LDR      r4,|L7.64|
000004  6820              LDR      r0,[r4,#0]  ; pInformation
000006  7a00              LDRB     r0,[r0,#8]
;;;986    
;;;987      if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
000008  2802              CMP      r0,#2
00000a  d011              BEQ      |L7.48|
00000c  2804              CMP      r0,#4
00000e  d00f              BEQ      |L7.48|
;;;988      {
;;;989        /* host aborts the transfer before finish */
;;;990        ControlState = STALLED;
;;;991      }
;;;992      else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
000010  2803              CMP      r0,#3
000012  d004              BEQ      |L7.30|
000014  2805              CMP      r0,#5
000016  d002              BEQ      |L7.30|
;;;993      {
;;;994        DataStageOut();
;;;995        ControlState = pInformation->ControlState; /* may be changed outside the function */
;;;996      }
;;;997    
;;;998      else if (ControlState == WAIT_STATUS_OUT)
000018  2807              CMP      r0,#7
00001a  d005              BEQ      |L7.40|
00001c  e008              B        |L7.48|
                  |L7.30|
00001e  f7fffffe          BL       DataStageOut
000022  6820              LDR      r0,[r4,#0]            ;995  ; pInformation
000024  7a00              LDRB     r0,[r0,#8]            ;995
000026  e004              B        |L7.50|
                  |L7.40|
;;;999      {
;;;1000       (*pProperty->Process_Status_OUT)();
000028  4806              LDR      r0,|L7.68|
00002a  6800              LDR      r0,[r0,#0]  ; pProperty
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  4780              BLX      r0
                  |L7.48|
;;;1001     #ifndef STM32F10X_CL
;;;1002       ControlState = STALLED;
;;;1003     #endif /* STM32F10X_CL */
;;;1004     }
;;;1005   
;;;1006   
;;;1007     /* Unexpect state, STALL the endpoint */
;;;1008     else
;;;1009     {
;;;1010       ControlState = STALLED;
000030  2008              MOVS     r0,#8
                  |L7.50|
;;;1011     }
;;;1012   
;;;1013     pInformation->ControlState = ControlState;
000032  6821              LDR      r1,[r4,#0]  ; pInformation
000034  7208              STRB     r0,[r1,#8]
;;;1014   
;;;1015     return Post0_Process();
000036  e8bd4010          POP      {r4,lr}
00003a  f7ffbffe          B.W      Post0_Process
;;;1016   }
;;;1017   
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      pInformation
                  |L7.68|
                          DCD      pProperty

                          AREA ||i.Post0_Process||, CODE, READONLY, ALIGN=2

                  Post0_Process PROC
;;;1025   *******************************************************************************/
;;;1026   uint8_t Post0_Process(void)
000000  480c              LDR      r0,|L8.52|
;;;1027   {
000002  b510              PUSH     {r4,lr}
;;;1028   #ifdef STM32F10X_CL  
;;;1029     USB_OTG_EP *ep;
;;;1030   #endif /* STM32F10X_CL */
;;;1031         
;;;1032     SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
000004  f890102c          LDRB     r1,[r0,#0x2c]  ; Device_Property
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       SetEPRxCount
;;;1033   
;;;1034     if (pInformation->ControlState == STALLED)
00000e  480a              LDR      r0,|L8.56|
000010  6800              LDR      r0,[r0,#0]  ; pInformation
000012  7a00              LDRB     r0,[r0,#8]
000014  2808              CMP      r0,#8
000016  d002              BEQ      |L8.30|
;;;1035     {
;;;1036       vSetEPRxStatus(EP_RX_STALL);
;;;1037       vSetEPTxStatus(EP_TX_STALL);
;;;1038     }
;;;1039   
;;;1040   #ifdef STM32F10X_CL
;;;1041     else if ((pInformation->ControlState == OUT_DATA) ||
;;;1042         (pInformation->ControlState == WAIT_STATUS_OUT))
;;;1043     {
;;;1044       ep = PCD_GetInEP(0);
;;;1045       ep->is_in = 0;
;;;1046       OTGD_FS_EP0StartXfer(ep);
;;;1047       
;;;1048       vSetEPTxStatus(EP_TX_VALID);
;;;1049     }
;;;1050     
;;;1051     else if ((pInformation->ControlState == IN_DATA) || 
;;;1052         (pInformation->ControlState == WAIT_STATUS_IN))
;;;1053     {
;;;1054       ep = PCD_GetInEP(0);
;;;1055       ep->is_in = 1;
;;;1056       OTGD_FS_EP0StartXfer(ep);    
;;;1057     }  
;;;1058   #endif /* STM32F10X_CL */
;;;1059   
;;;1060     return (pInformation->ControlState == PAUSE);
000018  2809              CMP      r0,#9
00001a  d009              BEQ      |L8.48|
00001c  e006              B        |L8.44|
                  |L8.30|
00001e  4907              LDR      r1,|L8.60|
000020  f44f5080          MOV      r0,#0x1000            ;1036
000024  8008              STRH     r0,[r1,#0]            ;1036
000026  4906              LDR      r1,|L8.64|
000028  2010              MOVS     r0,#0x10              ;1037
00002a  8008              STRH     r0,[r1,#0]            ;1037
                  |L8.44|
00002c  2000              MOVS     r0,#0
;;;1061   }
00002e  bd10              POP      {r4,pc}
                  |L8.48|
000030  2001              MOVS     r0,#1                 ;1060
000032  bd10              POP      {r4,pc}
;;;1062   
                          ENDP

                  |L8.52|
                          DCD      Device_Property
                  |L8.56|
                          DCD      pInformation
                  |L8.60|
                          DCD      SaveRState
                  |L8.64|
                          DCD      SaveTState

                          AREA ||i.SetDeviceAddress||, CODE, READONLY, ALIGN=2

                  SetDeviceAddress PROC
;;;1069   *******************************************************************************/
;;;1070   void SetDeviceAddress(uint8_t Val)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1071   {
;;;1072   #ifdef STM32F10X_CL 
;;;1073     PCD_EP_SetAddress ((uint8_t)Val);
;;;1074   #else 
;;;1075     uint32_t i;
;;;1076     uint32_t nEP = Device_Table.Total_Endpoint;
000002  490e              LDR      r1,|L9.60|
;;;1077   
;;;1078     /* set address in every used endpoint */
;;;1079     for (i = 0; i < nEP; i++)
;;;1080     {
;;;1081       _SetEPAddress((uint8_t)i, (uint8_t)i);
000004  4e0e              LDR      r6,|L9.64|
000006  f648778f          MOV      r7,#0x8f8f
00000a  780b              LDRB     r3,[r1,#0]            ;1076  ; Device_Table
00000c  2100              MOVS     r1,#0                 ;1079
00000e  f2480c80          MOV      r12,#0x8080
000012  e00a              B        |L9.42|
                  |L9.20|
000014  b2cc              UXTB     r4,r1
000016  eb060584          ADD      r5,r6,r4,LSL #2
00001a  682a              LDR      r2,[r5,#0]
00001c  b292              UXTH     r2,r2
00001e  403a              ANDS     r2,r2,r7
000020  4322              ORRS     r2,r2,r4
000022  ea42020c          ORR      r2,r2,r12
000026  602a              STR      r2,[r5,#0]
000028  1c49              ADDS     r1,r1,#1              ;1079
                  |L9.42|
00002a  4299              CMP      r1,r3                 ;1079
00002c  d3f2              BCC      |L9.20|
;;;1082     } /* for */
;;;1083     _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
00002e  4904              LDR      r1,|L9.64|
000030  f0400080          ORR      r0,r0,#0x80
000034  314c              ADDS     r1,r1,#0x4c
000036  6008              STR      r0,[r1,#0]
;;;1084   #endif  /* STM32F10X_CL */  
;;;1085   }
000038  bdf0              POP      {r4-r7,pc}
;;;1086   
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      Device_Table
                  |L9.64|
                          DCD      0x40005c00

                          AREA ||i.Setup0_Process||, CODE, READONLY, ALIGN=2

                  Setup0_Process PROC
;;;888    *******************************************************************************/
;;;889    uint8_t Setup0_Process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;890    {
;;;891    
;;;892      union
;;;893      {
;;;894        uint8_t* b;
;;;895        uint16_t* w;
;;;896      } pBuf;
;;;897    
;;;898    #ifdef STM32F10X_CL
;;;899      USB_OTG_EP *ep;
;;;900      uint16_t offset = 0;
;;;901     
;;;902      ep = PCD_GetOutEP(ENDP0);
;;;903      pBuf.b = ep->xfer_buff;
;;;904    #else  
;;;905      uint16_t offset = 1;
;;;906      
;;;907      pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
000002  4816              LDR      r0,|L10.92|
000004  6800              LDR      r0,[r0,#0]
;;;908    #endif /* STM32F10X_CL */
;;;909    
;;;910      if (pInformation->ControlState != PAUSE)
000006  4d17              LDR      r5,|L10.100|
000008  b281              UXTH     r1,r0                 ;907
00000a  4815              LDR      r0,|L10.96|
00000c  eb000141          ADD      r1,r0,r1,LSL #1       ;907
000010  6889              LDR      r1,[r1,#8]            ;907
000012  b289              UXTH     r1,r1                 ;907
000014  eb000441          ADD      r4,r0,r1,LSL #1       ;907
000018  6828              LDR      r0,[r5,#0]  ; pInformation
00001a  7a01              LDRB     r1,[r0,#8]
00001c  2909              CMP      r1,#9
00001e  d00f              BEQ      |L10.64|
;;;911      {
;;;912        pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
000020  7821              LDRB     r1,[r4,#0]
000022  7001              STRB     r1,[r0,#0]
;;;913        pInformation->USBbRequest = *pBuf.b++; /* bRequest */
000024  7861              LDRB     r1,[r4,#1]
000026  7041              STRB     r1,[r0,#1]
;;;914        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
;;;915        pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
000028  88a0              LDRH     r0,[r4,#4]
00002a  f7fffffe          BL       ByteSwap
00002e  6829              LDR      r1,[r5,#0]  ; pInformation
000030  8048              STRH     r0,[r1,#2]
;;;916        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
;;;917        pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
000032  8920              LDRH     r0,[r4,#8]
000034  f7fffffe          BL       ByteSwap
000038  6829              LDR      r1,[r5,#0]  ; pInformation
00003a  8088              STRH     r0,[r1,#4]
;;;918        pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
;;;919        pInformation->USBwLength = *pBuf.w; /* wLength */
00003c  89a0              LDRH     r0,[r4,#0xc]
00003e  80c8              STRH     r0,[r1,#6]
                  |L10.64|
;;;920      }
;;;921    
;;;922      pInformation->ControlState = SETTING_UP;
000040  6828              LDR      r0,[r5,#0]  ; pInformation
000042  2101              MOVS     r1,#1
000044  7201              STRB     r1,[r0,#8]
;;;923      if (pInformation->USBwLength == 0)
000046  88c0              LDRH     r0,[r0,#6]
000048  b128              CBZ      r0,|L10.86|
;;;924      {
;;;925        /* Setup with no data stage */
;;;926        NoData_Setup0();
;;;927      }
;;;928      else
;;;929      {
;;;930        /* Setup with data stage */
;;;931        Data_Setup0();
00004a  f7fffffe          BL       Data_Setup0
                  |L10.78|
;;;932      }
;;;933      return Post0_Process();
00004e  e8bd4070          POP      {r4-r6,lr}
000052  f7ffbffe          B.W      Post0_Process
                  |L10.86|
000056  f7fffffe          BL       NoData_Setup0
00005a  e7f8              B        |L10.78|
;;;934    }
;;;935    
                          ENDP

                  |L10.92|
                          DCD      0x40005c50
                  |L10.96|
                          DCD      0x40006000
                  |L10.100|
                          DCD      pInformation

                          AREA ||i.Standard_ClearFeature||, CODE, READONLY, ALIGN=2

                  Standard_ClearFeature PROC
;;;257    *******************************************************************************/
;;;258    RESULT Standard_ClearFeature(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;259    {
;;;260      uint32_t     Type_Rec = Type_Recipient;
000004  4834              LDR      r0,|L11.216|
000006  6801              LDR      r1,[r0,#0]  ; pInformation
000008  7808              LDRB     r0,[r1,#0]
00000a  f010007f          ANDS     r0,r0,#0x7f
;;;261      uint32_t     Status;
;;;262    
;;;263    
;;;264      if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
00000e  d002              BEQ      |L11.22|
;;;265      {/*Device Clear Feature*/
;;;266        ClrBit(pInformation->Current_Feature, 5);
;;;267        return USB_SUCCESS;
;;;268      }
;;;269      else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
000010  2802              CMP      r0,#2
000012  d005              BEQ      |L11.32|
000014  e05e              B        |L11.212|
                  |L11.22|
000016  7a48              LDRB     r0,[r1,#9]            ;266
000018  f00000df          AND      r0,r0,#0xdf           ;266
00001c  7248              STRB     r0,[r1,#9]            ;266
00001e  e047              B        |L11.176|
                  |L11.32|
;;;270      {/*EndPoint Clear Feature*/
;;;271        DEVICE* pDev;
;;;272        uint32_t Related_Endpoint;
;;;273        uint32_t wIndex0;
;;;274        uint32_t rEP;
;;;275    
;;;276        if ((pInformation->USBwValue != ENDPOINT_STALL)
000020  8848              LDRH     r0,[r1,#2]
000022  2800              CMP      r0,#0
000024  d156              BNE      |L11.212|
;;;277            || (pInformation->USBwIndex1 != 0))
000026  7908              LDRB     r0,[r1,#4]
000028  2800              CMP      r0,#0
00002a  d153              BNE      |L11.212|
;;;278        {
;;;279          return USB_UNSUPPORT;
;;;280        }
;;;281    
;;;282        pDev = &Device_Table;
;;;283        wIndex0 = pInformation->USBwIndex0;
00002c  794a              LDRB     r2,[r1,#5]
;;;284        rEP = wIndex0 & ~0x80;
;;;285        Related_Endpoint = ENDP0 + rEP;
;;;286    
;;;287        if (ValBit(pInformation->USBwIndex0, 7))
;;;288        {
;;;289          /*Get Status of endpoint & stall the request if the related_ENdpoint
;;;290          is Disabled*/
;;;291          Status = _GetEPTxStatus(Related_Endpoint);
00002e  4c2c              LDR      r4,|L11.224|
000030  f0220080          BIC      r0,r2,#0x80           ;284
000034  0615              LSLS     r5,r2,#24             ;287
000036  4b29              LDR      r3,|L11.220|
;;;292        }
;;;293        else
;;;294        {
;;;295          Status = _GetEPRxStatus(Related_Endpoint);
000038  f8545020          LDR      r5,[r4,r0,LSL #2]
00003c  d503              BPL      |L11.70|
00003e  f3c51501          UBFX     r5,r5,#4,#2           ;291
000042  012d              LSLS     r5,r5,#4              ;291
000044  e002              B        |L11.76|
                  |L11.70|
000046  f3c53501          UBFX     r5,r5,#12,#2
00004a  032d              LSLS     r5,r5,#12
                  |L11.76|
;;;296        }
;;;297    
;;;298        if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
00004c  781e              LDRB     r6,[r3,#0]
00004e  4603              MOV      r3,r0
000050  4286              CMP      r6,r0
000052  d93f              BLS      |L11.212|
000054  b37d              CBZ      r5,|L11.182|
;;;299            || (pInformation->Current_Configuration == 0))
000056  7a89              LDRB     r1,[r1,#0xa]
000058  b369              CBZ      r1,|L11.182|
;;;300        {
;;;301          return USB_UNSUPPORT;
;;;302        }
;;;303    
;;;304    
;;;305        if (wIndex0 & 0x80)
00005a  0611              LSLS     r1,r2,#24
00005c  d50e              BPL      |L11.124|
;;;306        {
;;;307          /* IN endpoint */
;;;308          if (_GetTxStallStatus(Related_Endpoint ))
00005e  f8541020          LDR      r1,[r4,r0,LSL #2]
000062  f3c11101          UBFX     r1,r1,#4,#2
000066  2901              CMP      r1,#1
000068  d11e              BNE      |L11.168|
;;;309          {
;;;310          #ifndef STM32F10X_CL
;;;311            ClearDTOG_TX(Related_Endpoint);
00006a  b2d8              UXTB     r0,r3
00006c  4604              MOV      r4,r0
00006e  f7fffffe          BL       ClearDTOG_TX
;;;312          #endif /* STM32F10X_CL */
;;;313            SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
000072  2130              MOVS     r1,#0x30
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       SetEPTxStatus
00007a  e015              B        |L11.168|
                  |L11.124|
;;;314          }
;;;315        }
;;;316        else
;;;317        {
;;;318          /* OUT endpoint */
;;;319          if (_GetRxStallStatus(Related_Endpoint))
00007c  eb040580          ADD      r5,r4,r0,LSL #2
000080  6829              LDR      r1,[r5,#0]
000082  f3c13101          UBFX     r1,r1,#12,#2
000086  2901              CMP      r1,#1
000088  d10e              BNE      |L11.168|
;;;320          {
;;;321            if (Related_Endpoint == ENDP0)
;;;322            {
;;;323              /* After clear the STALL, enable the default endpoint receiver */
;;;324              SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
;;;325              _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
00008a  f64b768f          MOV      r6,#0xbf8f
00008e  f2480780          MOV      r7,#0x8080
000092  b188              CBZ      r0,|L11.184|
;;;326            }
;;;327            else
;;;328            {
;;;329            #ifndef STM32F10X_CL
;;;330              ClearDTOG_RX(Related_Endpoint);
000094  b2d8              UXTB     r0,r3
000096  f7fffffe          BL       ClearDTOG_RX
;;;331            #endif /* STM32F10X_CL */
;;;332              _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
00009a  6828              LDR      r0,[r5,#0]
00009c  b280              UXTH     r0,r0
00009e  4030              ANDS     r0,r0,r6
0000a0  f4805040          EOR      r0,r0,#0x3000
0000a4  4338              ORRS     r0,r0,r7
0000a6  6028              STR      r0,[r5,#0]
                  |L11.168|
;;;333            }
;;;334          }
;;;335        }
;;;336        pUser_Standard_Requests->User_ClearFeature();
0000a8  480e              LDR      r0,|L11.228|
0000aa  6800              LDR      r0,[r0,#0]  ; pUser_Standard_Requests
0000ac  6940              LDR      r0,[r0,#0x14]
0000ae  4780              BLX      r0
                  |L11.176|
;;;337        return USB_SUCCESS;
0000b0  2000              MOVS     r0,#0
                  |L11.178|
;;;338      }
;;;339    
;;;340      return USB_UNSUPPORT;
;;;341    }
0000b2  e8bd81f0          POP      {r4-r8,pc}
                  |L11.182|
0000b6  e00d              B        |L11.212|
                  |L11.184|
0000b8  480b              LDR      r0,|L11.232|
0000ba  f890102c          LDRB     r1,[r0,#0x2c]         ;324  ; Device_Property
0000be  2000              MOVS     r0,#0                 ;324
0000c0  f7fffffe          BL       SetEPRxCount
0000c4  6820              LDR      r0,[r4,#0]            ;325
0000c6  b280              UXTH     r0,r0                 ;325
0000c8  4030              ANDS     r0,r0,r6              ;325
0000ca  f4805040          EOR      r0,r0,#0x3000         ;325
0000ce  4338              ORRS     r0,r0,r7              ;325
0000d0  6020              STR      r0,[r4,#0]            ;325
0000d2  e7e9              B        |L11.168|
                  |L11.212|
0000d4  2002              MOVS     r0,#2                 ;340
0000d6  e7ec              B        |L11.178|
;;;342    
                          ENDP

                  |L11.216|
                          DCD      pInformation
                  |L11.220|
                          DCD      Device_Table
                  |L11.224|
                          DCD      0x40005c00
                  |L11.228|
                          DCD      pUser_Standard_Requests
                  |L11.232|
                          DCD      Device_Property

                          AREA ||i.Standard_GetConfiguration||, CODE, READONLY, ALIGN=2

                  Standard_GetConfiguration PROC
;;;73     *******************************************************************************/
;;;74     uint8_t *Standard_GetConfiguration(uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;75     {
;;;76       if (Length == 0)
;;;77       {
;;;78         pInformation->Ctrl_Info.Usb_wLength =
000002  4c07              LDR      r4,|L12.32|
000004  b130              CBZ      r0,|L12.20|
;;;79           sizeof(pInformation->Current_Configuration);
;;;80         return 0;
;;;81       }
;;;82       pUser_Standard_Requests->User_GetConfiguration();
000006  4807              LDR      r0,|L12.36|
000008  6800              LDR      r0,[r0,#0]  ; pUser_Standard_Requests
00000a  6800              LDR      r0,[r0,#0]
00000c  4780              BLX      r0
;;;83       return (uint8_t *)&pInformation->Current_Configuration;
00000e  6820              LDR      r0,[r4,#0]  ; pInformation
000010  300a              ADDS     r0,r0,#0xa
;;;84     }
000012  bd10              POP      {r4,pc}
                  |L12.20|
000014  6821              LDR      r1,[r4,#0]            ;78  ; pInformation
000016  2001              MOVS     r0,#1                 ;78
000018  8208              STRH     r0,[r1,#0x10]         ;78
00001a  2000              MOVS     r0,#0                 ;80
00001c  bd10              POP      {r4,pc}
;;;85     
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      pInformation
                  |L12.36|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_GetDescriptorData||, CODE, READONLY, ALIGN=2

                  Standard_GetDescriptorData PROC
;;;430    *******************************************************************************/
;;;431    uint8_t *Standard_GetDescriptorData(uint16_t Length, ONE_DESCRIPTOR *pDesc)
000000  4a05              LDR      r2,|L13.24|
;;;432    {
;;;433      uint32_t  wOffset;
;;;434    
;;;435      wOffset = pInformation->Ctrl_Info.Usb_wOffset;
000002  6813              LDR      r3,[r2,#0]  ; pInformation
000004  8a5a              LDRH     r2,[r3,#0x12]
;;;436      if (Length == 0)
000006  b110              CBZ      r0,|L13.14|
;;;437      {
;;;438        pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
;;;439        return 0;
;;;440      }
;;;441    
;;;442      return pDesc->Descriptor + wOffset;
000008  6808              LDR      r0,[r1,#0]
00000a  4410              ADD      r0,r0,r2
;;;443    }
00000c  4770              BX       lr
                  |L13.14|
00000e  8888              LDRH     r0,[r1,#4]            ;438
000010  1a80              SUBS     r0,r0,r2              ;438
000012  8218              STRH     r0,[r3,#0x10]         ;438
000014  2000              MOVS     r0,#0                 ;439
000016  4770              BX       lr
;;;444    
                          ENDP

                  |L13.24|
                          DCD      pInformation

                          AREA ||i.Standard_GetInterface||, CODE, READONLY, ALIGN=2

                  Standard_GetInterface PROC
;;;119    *******************************************************************************/
;;;120    uint8_t *Standard_GetInterface(uint16_t Length)
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122      if (Length == 0)
;;;123      {
;;;124        pInformation->Ctrl_Info.Usb_wLength =
000002  4c07              LDR      r4,|L14.32|
000004  b130              CBZ      r0,|L14.20|
;;;125          sizeof(pInformation->Current_AlternateSetting);
;;;126        return 0;
;;;127      }
;;;128      pUser_Standard_Requests->User_GetInterface();
000006  4807              LDR      r0,|L14.36|
000008  6800              LDR      r0,[r0,#0]  ; pUser_Standard_Requests
00000a  6880              LDR      r0,[r0,#8]
00000c  4780              BLX      r0
;;;129      return (uint8_t *)&pInformation->Current_AlternateSetting;
00000e  6820              LDR      r0,[r4,#0]  ; pInformation
000010  300c              ADDS     r0,r0,#0xc
;;;130    }
000012  bd10              POP      {r4,pc}
                  |L14.20|
000014  6821              LDR      r1,[r4,#0]            ;124  ; pInformation
000016  2001              MOVS     r0,#1                 ;124
000018  8208              STRH     r0,[r1,#0x10]         ;124
00001a  2000              MOVS     r0,#0                 ;126
00001c  bd10              POP      {r4,pc}
;;;131    
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      pInformation
                  |L14.36|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_GetStatus||, CODE, READONLY, ALIGN=2

                  Standard_GetStatus PROC
;;;175    *******************************************************************************/
;;;176    uint8_t *Standard_GetStatus(uint16_t Length)
000000  491f              LDR      r1,|L15.128|
;;;177    {
000002  b510              PUSH     {r4,lr}
;;;178      if (Length == 0)
;;;179      {
;;;180        pInformation->Ctrl_Info.Usb_wLength = 2;
000004  6809              LDR      r1,[r1,#0]
000006  b160              CBZ      r0,|L15.34|
;;;181        return 0;
;;;182      }
;;;183    
;;;184      /* Reset Status Information */
;;;185      StatusInfo.w = 0;
000008  481e              LDR      r0,|L15.132|
00000a  2200              MOVS     r2,#0
00000c  8002              STRH     r2,[r0,#0]
;;;186    
;;;187      if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
00000e  780a              LDRB     r2,[r1,#0]
000010  0653              LSLS     r3,r2,#25
000012  d00a              BEQ      |L15.42|
;;;188      {
;;;189        /*Get Device Status */
;;;190        uint8_t Feature = pInformation->Current_Feature;
;;;191    
;;;192        /* Remote Wakeup enabled */
;;;193        if (ValBit(Feature, 5))
;;;194        {
;;;195          SetBit(StatusInfo0, 1);
;;;196        }
;;;197        else
;;;198        {
;;;199          ClrBit(StatusInfo0, 1);
;;;200        }      
;;;201    
;;;202        /* Bus-powered */
;;;203        if (ValBit(Feature, 6))
;;;204        {
;;;205          SetBit(StatusInfo0, 0);
;;;206        }
;;;207        else /* Self-powered */
;;;208        {
;;;209          ClrBit(StatusInfo0, 0);
;;;210        }
;;;211      }
;;;212      /*Interface Status*/
;;;213      else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
000014  f002027f          AND      r2,r2,#0x7f
000018  2a01              CMP      r2,#1
00001a  d016              BEQ      |L15.74|
;;;214      {
;;;215        return (uint8_t *)&StatusInfo;
;;;216      }
;;;217      /*Get EndPoint Status*/
;;;218      else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
00001c  2a02              CMP      r2,#2
00001e  d016              BEQ      |L15.78|
000020  e001              B        |L15.38|
                  |L15.34|
000022  2002              MOVS     r0,#2                 ;180
000024  8208              STRH     r0,[r1,#0x10]         ;180
                  |L15.38|
;;;219      {
;;;220        uint8_t Related_Endpoint;
;;;221        uint8_t wIndex0 = pInformation->USBwIndex0;
;;;222    
;;;223        Related_Endpoint = (wIndex0 & 0x0f);
;;;224        if (ValBit(wIndex0, 7))
;;;225        {
;;;226          /* IN endpoint */
;;;227          if (_GetTxStallStatus(Related_Endpoint))
;;;228          {
;;;229            SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
;;;230          }
;;;231        }
;;;232        else
;;;233        {
;;;234          /* OUT endpoint */
;;;235          if (_GetRxStallStatus(Related_Endpoint))
;;;236          {
;;;237            SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
;;;238          }
;;;239        }
;;;240    
;;;241      }
;;;242      else
;;;243      {
;;;244        return NULL;
000026  2000              MOVS     r0,#0
;;;245      }
;;;246      pUser_Standard_Requests->User_GetStatus();
;;;247      return (uint8_t *)&StatusInfo;
;;;248    }
000028  bd10              POP      {r4,pc}
                  |L15.42|
00002a  7a49              LDRB     r1,[r1,#9]            ;190
00002c  068a              LSLS     r2,r1,#26             ;193
00002e  7802              LDRB     r2,[r0,#0]            ;199  ; StatusInfo
000030  d502              BPL      |L15.56|
000032  f0420202          ORR      r2,r2,#2              ;195
000036  e001              B        |L15.60|
                  |L15.56|
000038  f00202fd          AND      r2,r2,#0xfd           ;199
                  |L15.60|
00003c  0649              LSLS     r1,r1,#25             ;203
00003e  7002              STRB     r2,[r0,#0]            ;199
000040  b2d1              UXTB     r1,r2                 ;209
000042  d410              BMI      |L15.102|
000044  f00101fe          AND      r1,r1,#0xfe           ;209
000048  e00f              B        |L15.106|
                  |L15.74|
00004a  480e              LDR      r0,|L15.132|
00004c  bd10              POP      {r4,pc}
                  |L15.78|
00004e  794a              LDRB     r2,[r1,#5]            ;221
000050  f002010f          AND      r1,r2,#0xf            ;223
000054  0613              LSLS     r3,r2,#24             ;224
000056  4a0c              LDR      r2,|L15.136|
000058  f8521021          LDR      r1,[r2,r1,LSL #2]     ;235
00005c  d507              BPL      |L15.110|
00005e  f3c11101          UBFX     r1,r1,#4,#2           ;227
000062  e006              B        |L15.114|
                  |L15.100|
000064  7801              LDRB     r1,[r0,#0]            ;229  ; StatusInfo
                  |L15.102|
000066  f0410101          ORR      r1,r1,#1              ;229
                  |L15.106|
00006a  7001              STRB     r1,[r0,#0]            ;229
00006c  e003              B        |L15.118|
                  |L15.110|
00006e  f3c13101          UBFX     r1,r1,#12,#2          ;235
                  |L15.114|
000072  2901              CMP      r1,#1                 ;227
000074  d0f6              BEQ      |L15.100|
                  |L15.118|
000076  4805              LDR      r0,|L15.140|
000078  6800              LDR      r0,[r0,#0]            ;246  ; pUser_Standard_Requests
00007a  6900              LDR      r0,[r0,#0x10]         ;246
00007c  4780              BLX      r0                    ;246
00007e  e7e4              B        |L15.74|
;;;249    
                          ENDP

                  |L15.128|
                          DCD      pInformation
                  |L15.132|
                          DCD      ||.data||+0x2
                  |L15.136|
                          DCD      0x40005c00
                  |L15.140|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_SetConfiguration||, CODE, READONLY, ALIGN=2

                  Standard_SetConfiguration PROC
;;;94     *******************************************************************************/
;;;95     RESULT Standard_SetConfiguration(void)
000000  480a              LDR      r0,|L16.44|
;;;96     {
000002  b510              PUSH     {r4,lr}
;;;97     
;;;98       if ((pInformation->USBwValue0 <=
000004  6800              LDR      r0,[r0,#0]  ; pInformation
000006  4a0a              LDR      r2,|L16.48|
000008  78c1              LDRB     r1,[r0,#3]
00000a  7852              LDRB     r2,[r2,#1]  ; Device_Table
00000c  4291              CMP      r1,r2
00000e  d803              BHI      |L16.24|
;;;99           Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
000010  7882              LDRB     r2,[r0,#2]
000012  b90a              CBNZ     r2,|L16.24|
;;;100          && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
000014  8882              LDRH     r2,[r0,#4]
000016  b10a              CBZ      r2,|L16.28|
                  |L16.24|
;;;101      {
;;;102        pInformation->Current_Configuration = pInformation->USBwValue0;
;;;103        pUser_Standard_Requests->User_SetConfiguration();
;;;104        return USB_SUCCESS;
;;;105      }
;;;106      else
;;;107      {
;;;108        return USB_UNSUPPORT;
000018  2002              MOVS     r0,#2
;;;109      }
;;;110    }
00001a  bd10              POP      {r4,pc}
                  |L16.28|
00001c  7281              STRB     r1,[r0,#0xa]          ;102
00001e  4805              LDR      r0,|L16.52|
000020  6800              LDR      r0,[r0,#0]            ;103  ; pUser_Standard_Requests
000022  6840              LDR      r0,[r0,#4]            ;103
000024  4780              BLX      r0                    ;103
000026  2000              MOVS     r0,#0                 ;104
000028  bd10              POP      {r4,pc}
;;;111    
                          ENDP

00002a  0000              DCW      0x0000
                  |L16.44|
                          DCD      pInformation
                  |L16.48|
                          DCD      Device_Table
                  |L16.52|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_SetDeviceFeature||, CODE, READONLY, ALIGN=2

                  Standard_SetDeviceFeature PROC
;;;404    *******************************************************************************/
;;;405    RESULT Standard_SetDeviceFeature(void)
000000  4806              LDR      r0,|L17.28|
;;;406    {
000002  b510              PUSH     {r4,lr}
;;;407      SetBit(pInformation->Current_Feature, 5);
000004  6800              LDR      r0,[r0,#0]  ; pInformation
000006  7a41              LDRB     r1,[r0,#9]
000008  f0410120          ORR      r1,r1,#0x20
00000c  7241              STRB     r1,[r0,#9]
;;;408      pUser_Standard_Requests->User_SetDeviceFeature();
00000e  4804              LDR      r0,|L17.32|
000010  6800              LDR      r0,[r0,#0]  ; pUser_Standard_Requests
000012  69c0              LDR      r0,[r0,#0x1c]
000014  4780              BLX      r0
;;;409      return USB_SUCCESS;
000016  2000              MOVS     r0,#0
;;;410    }
000018  bd10              POP      {r4,pc}
;;;411    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      pInformation
                  |L17.32|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_SetEndPointFeature||, CODE, READONLY, ALIGN=2

                  Standard_SetEndPointFeature PROC
;;;350    *******************************************************************************/
;;;351    RESULT Standard_SetEndPointFeature(void)
000000  b570              PUSH     {r4-r6,lr}
;;;352    {
;;;353      uint32_t    wIndex0;
;;;354      uint32_t    Related_Endpoint;
;;;355      uint32_t    rEP;
;;;356      uint32_t    Status;
;;;357    
;;;358      wIndex0 = pInformation->USBwIndex0;
000002  481c              LDR      r0,|L18.116|
000004  6803              LDR      r3,[r0,#0]  ; pInformation
;;;359      rEP = wIndex0 & ~0x80;
;;;360      Related_Endpoint = ENDP0 + rEP;
;;;361    
;;;362      if (ValBit(pInformation->USBwIndex0, 7))
;;;363      {
;;;364        /* get Status of endpoint & stall the request if the related_ENdpoint
;;;365        is Disabled*/
;;;366        Status = _GetEPTxStatus(Related_Endpoint);
000006  481c              LDR      r0,|L18.120|
000008  7959              LDRB     r1,[r3,#5]            ;358
00000a  f0210580          BIC      r5,r1,#0x80           ;359
00000e  eb000085          ADD      r0,r0,r5,LSL #2
000012  060c              LSLS     r4,r1,#24             ;362
;;;367      }
;;;368      else
;;;369      {
;;;370        Status = _GetEPRxStatus(Related_Endpoint);
000014  6804              LDR      r4,[r0,#0]
000016  f0210280          BIC      r2,r1,#0x80           ;359
00001a  d503              BPL      |L18.36|
00001c  f3c41401          UBFX     r4,r4,#4,#2           ;366
000020  0124              LSLS     r4,r4,#4              ;366
000022  e002              B        |L18.42|
                  |L18.36|
000024  f3c43401          UBFX     r4,r4,#12,#2
000028  0324              LSLS     r4,r4,#12
                  |L18.42|
;;;371      }
;;;372    
;;;373      if (Related_Endpoint >= Device_Table.Total_Endpoint
00002a  4d14              LDR      r5,|L18.124|
00002c  782d              LDRB     r5,[r5,#0]  ; Device_Table
00002e  4295              CMP      r5,r2
000030  d911              BLS      |L18.86|
;;;374          || pInformation->USBwValue != 0 || Status == 0
000032  885a              LDRH     r2,[r3,#2]
000034  b97a              CBNZ     r2,|L18.86|
000036  b174              CBZ      r4,|L18.86|
;;;375          || pInformation->Current_Configuration == 0)
000038  7a9a              LDRB     r2,[r3,#0xa]
00003a  b162              CBZ      r2,|L18.86|
;;;376      {
;;;377        return USB_UNSUPPORT;
;;;378      }
;;;379      else
;;;380      {
;;;381        if (wIndex0 & 0x80)
00003c  0609              LSLS     r1,r1,#24
00003e  2900              CMP      r1,#0
;;;382        {
;;;383          /* IN endpoint */
;;;384          _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
;;;385        }
;;;386    
;;;387        else
;;;388        {
;;;389          /* OUT endpoint */
;;;390          _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
000040  6801              LDR      r1,[r0,#0]
000042  f2480280          MOV      r2,#0x8080            ;384
000046  b289              UXTH     r1,r1
000048  da07              BGE      |L18.90|
00004a  f64873bf          MOV      r3,#0x8fbf            ;384
00004e  4019              ANDS     r1,r1,r3              ;384
000050  f0810110          EOR      r1,r1,#0x10           ;384
000054  e006              B        |L18.100|
                  |L18.86|
000056  2002              MOVS     r0,#2                 ;377
;;;391        }
;;;392      }
;;;393      pUser_Standard_Requests->User_SetEndPointFeature();
;;;394      return USB_SUCCESS;
;;;395    }
000058  bd70              POP      {r4-r6,pc}
                  |L18.90|
00005a  f64b738f          MOV      r3,#0xbf8f            ;390
00005e  4019              ANDS     r1,r1,r3              ;390
000060  f4815180          EOR      r1,r1,#0x1000         ;390
                  |L18.100|
000064  4311              ORRS     r1,r1,r2              ;384
000066  6001              STR      r1,[r0,#0]            ;384
000068  4805              LDR      r0,|L18.128|
00006a  6800              LDR      r0,[r0,#0]            ;393  ; pUser_Standard_Requests
00006c  6980              LDR      r0,[r0,#0x18]         ;393
00006e  4780              BLX      r0                    ;393
000070  2000              MOVS     r0,#0                 ;394
000072  bd70              POP      {r4-r6,pc}
;;;396    
                          ENDP

                  |L18.116|
                          DCD      pInformation
                  |L18.120|
                          DCD      0x40005c00
                  |L18.124|
                          DCD      Device_Table
                  |L18.128|
                          DCD      pUser_Standard_Requests

                          AREA ||i.Standard_SetInterface||, CODE, READONLY, ALIGN=2

                  Standard_SetInterface PROC
;;;140    *******************************************************************************/
;;;141    RESULT Standard_SetInterface(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143      RESULT Re;
;;;144      /*Test if the specified Interface and Alternate Setting are supported by
;;;145        the application Firmware*/
;;;146      Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
000002  4c0e              LDR      r4,|L19.60|
000004  4a0e              LDR      r2,|L19.64|
000006  6820              LDR      r0,[r4,#0]  ; pInformation
000008  6812              LDR      r2,[r2,#0]  ; pProperty
00000a  78c1              LDRB     r1,[r0,#3]
00000c  6992              LDR      r2,[r2,#0x18]
00000e  7940              LDRB     r0,[r0,#5]
000010  4790              BLX      r2
;;;147    
;;;148      if (pInformation->Current_Configuration != 0)
000012  6821              LDR      r1,[r4,#0]  ; pInformation
000014  7a8a              LDRB     r2,[r1,#0xa]
000016  b122              CBZ      r2,|L19.34|
;;;149      {
;;;150        if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
000018  b918              CBNZ     r0,|L19.34|
00001a  7908              LDRB     r0,[r1,#4]
00001c  b908              CBNZ     r0,|L19.34|
;;;151            || (pInformation->USBwValue1 != 0))
00001e  7888              LDRB     r0,[r1,#2]
000020  b108              CBZ      r0,|L19.38|
                  |L19.34|
;;;152        {
;;;153          return  USB_UNSUPPORT;
;;;154        }
;;;155        else if (Re == USB_SUCCESS)
;;;156        {
;;;157          pUser_Standard_Requests->User_SetInterface();
;;;158          pInformation->Current_Interface = pInformation->USBwIndex0;
;;;159          pInformation->Current_AlternateSetting = pInformation->USBwValue0;
;;;160          return USB_SUCCESS;
;;;161        }
;;;162    
;;;163      }
;;;164    
;;;165      return USB_UNSUPPORT;
000022  2002              MOVS     r0,#2
;;;166    }
000024  bd10              POP      {r4,pc}
                  |L19.38|
000026  4807              LDR      r0,|L19.68|
000028  6800              LDR      r0,[r0,#0]            ;157  ; pUser_Standard_Requests
00002a  68c0              LDR      r0,[r0,#0xc]          ;157
00002c  4780              BLX      r0                    ;157
00002e  6820              LDR      r0,[r4,#0]            ;158  ; pInformation
000030  7941              LDRB     r1,[r0,#5]            ;158
000032  72c1              STRB     r1,[r0,#0xb]          ;158
000034  78c1              LDRB     r1,[r0,#3]            ;159
000036  7301              STRB     r1,[r0,#0xc]          ;159
000038  2000              MOVS     r0,#0                 ;160
00003a  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L19.60|
                          DCD      pInformation
                  |L19.64|
                          DCD      pProperty
                  |L19.68|
                          DCD      pUser_Standard_Requests

                          AREA ||.data||, DATA, ALIGN=1

                  Data_Mul_MaxPacketSize
000000  0000              DCB      0x00,0x00
                  StatusInfo
000002  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32_USB-FS-Device_Driver\\src\\usb_core.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_core_c_0b05b142____REV16|
#line 114 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_core_c_0b05b142____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_core_c_0b05b142____REVSH|
#line 128
|__asm___10_usb_core_c_0b05b142____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
