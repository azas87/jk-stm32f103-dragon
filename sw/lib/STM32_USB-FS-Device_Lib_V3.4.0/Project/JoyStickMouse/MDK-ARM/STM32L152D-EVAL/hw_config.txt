; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\STM32L152D-EVAL\hw_config.o --asm_dir=.\STM32L152D-EVAL\ --list_dir=.\STM32L152D-EVAL\ --depend=.\STM32L152D-EVAL\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152D_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;192    *******************************************************************************/
;;;193    void Enter_LowPowerMode(void)
000000  4903              LDR      r1,|L1.16|
;;;194    {
;;;195      /* Set the device state to suspend */
;;;196      bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;197    
;;;198      /* Clear EXTI Line18 pending bit */
;;;199    //  EXTI_ClearITPendingBit(KEY_BUTTON_EXTI_LINE);
;;;200    
;;;201      /* Request to enter STOP mode with regulator in low power mode */
;;;202      PWR_EnterSTOPMode(PWR_Regulator_LowPower, PWR_STOPEntry_WFI);
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7ffbffe          B.W      PWR_EnterSTOPMode
;;;203    }
;;;204    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      bDeviceState

                          AREA ||i.GPIO_AINConfig||, CODE, READONLY, ALIGN=2

                  GPIO_AINConfig PROC
;;;147    *******************************************************************************/
;;;148    void GPIO_AINConfig(void)
000000  b508              PUSH     {r3,lr}
;;;149    {
;;;150      GPIO_InitTypeDef GPIO_InitStructure;
;;;151    
;;;152    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;153      /* Enable all GPIOs Clock*/
;;;154      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ALLGPIO, ENABLE);  
;;;155    #else  
;;;156      /* Enable all GPIOs Clock*/
;;;157      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ALLGPIO, ENABLE);
000002  2101              MOVS     r1,#1
000004  f44f70fe          MOV      r0,#0x1fc
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;158    #endif /* STM32L1XX_XD */
;;;159      
;;;160      /* Configure all GPIO port pins in Analog Input mode (floating input trigger OFF) */
;;;161      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
00000c  f64f70ff          MOV      r0,#0xffff
000010  f8ad0000          STRH     r0,[sp,#0]
;;;162      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000014  2000              MOVS     r0,#0
000016  f88d0003          STRB     r0,[sp,#3]
;;;163      //GPIO_Init(GPIOA, &GPIO_InitStructure); // Some GPIOA pins are used for JTAG and USB
;;;164      GPIO_Init(GPIOB, &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  480b              LDR      r0,|L2.76|
00001e  f7fffffe          BL       GPIO_Init
;;;165      GPIO_Init(GPIOC, &GPIO_InitStructure);
000022  4669              MOV      r1,sp
000024  480a              LDR      r0,|L2.80|
000026  f7fffffe          BL       GPIO_Init
;;;166      GPIO_Init(GPIOD, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4809              LDR      r0,|L2.84|
00002e  f7fffffe          BL       GPIO_Init
;;;167      GPIO_Init(GPIOE, &GPIO_InitStructure);
000032  4669              MOV      r1,sp
000034  4808              LDR      r0,|L2.88|
000036  f7fffffe          BL       GPIO_Init
;;;168    
;;;169    #if defined (USE_STM32L152_EVAL)
;;;170      GPIO_Init(GPIOH, &GPIO_InitStructure);
;;;171    #endif /* USE_STM32L152_EVAL */  
;;;172    
;;;173    #if defined (USE_STM32L152D_EVAL)
;;;174      GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;175      GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;176      GPIO_Init(GPIOH, &GPIO_InitStructure);
;;;177    #endif /* USE_STM32L152D_EVAL */ 
;;;178      
;;;179    #if defined (USE_STM3210E_EVAL) || defined (USE_STM3210C_EVAL)
;;;180      GPIO_Init(GPIOF, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4807              LDR      r0,|L2.92|
00003e  f7fffffe          BL       GPIO_Init
;;;181      GPIO_Init(GPIOG, &GPIO_InitStructure);
000042  4669              MOV      r1,sp
000044  4806              LDR      r0,|L2.96|
000046  f7fffffe          BL       GPIO_Init
;;;182    #endif /* USE_STM3210E_EVAL */
;;;183    
;;;184    }
00004a  bd08              POP      {r3,pc}
;;;185    
                          ENDP

                  |L2.76|
                          DCD      0x40010c00
                  |L2.80|
                          DCD      0x40011000
                  |L2.84|
                          DCD      0x40011400
                  |L2.88|
                          DCD      0x40011800
                  |L2.92|
                          DCD      0x40011c00
                  |L2.96|
                          DCD      0x40012000

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;396    *******************************************************************************/
;;;397    void Get_SerialNum(void)
000000  480a              LDR      r0,|L3.44|
;;;398    {
000002  b510              PUSH     {r4,lr}
;;;399      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;400    
;;;401    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;402      Device_Serial0 = *(__IO uint32_t*)(0x1FF80050);
;;;403      Device_Serial1 = *(__IO uint32_t*)(0x1FF80054);
;;;404      Device_Serial2 = *(__IO uint32_t*)(0x1FF80064);
;;;405    #else  
;;;406      Device_Serial0 = *(__IO uint32_t*)(0x1FFFF7E8);
000004  6801              LDR      r1,[r0,#0]
;;;407      Device_Serial1 = *(__IO uint32_t*)(0x1FFFF7EC);
000006  1d00              ADDS     r0,r0,#4
000008  6804              LDR      r4,[r0,#0]
;;;408      Device_Serial2 = *(__IO uint32_t*)(0x1FFFF7F0);
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
;;;409    #endif /* STM32L1XX_XD */
;;;410      
;;;411      Device_Serial0 += Device_Serial2;
00000e  1808              ADDS     r0,r1,r0
;;;412    
;;;413      if (Device_Serial0 != 0)
000010  d00b              BEQ      |L3.42|
;;;414      {
;;;415        IntToUnicode (Device_Serial0, &Joystick_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L3.48|
000016  f7fffffe          BL       IntToUnicode
;;;416        IntToUnicode (Device_Serial1, &Joystick_StringSerial[18], 4);
00001a  4905              LDR      r1,|L3.48|
00001c  4620              MOV      r0,r4
00001e  2204              MOVS     r2,#4
000020  e8bd4010          POP      {r4,lr}
000024  3110              ADDS     r1,r1,#0x10
000026  f7ffbffe          B.W      IntToUnicode
                  |L3.42|
;;;417      }
;;;418    }
00002a  bd10              POP      {r4,pc}
;;;419    
                          ENDP

                  |L3.44|
                          DCD      0x1ffff7e8
                  |L3.48|
                          DCD      Joystick_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=1

                  IntToUnicode PROC
;;;426    *******************************************************************************/
;;;427    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;428    {
;;;429      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;430      
;;;431      for( idx = 0 ; idx < len ; idx ++)
;;;432      {
;;;433        if( ((value >> 28)) < 0xA )
000004  250a              MOVS     r5,#0xa
;;;434        {
;;;435          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2730              MOVS     r7,#0x30
;;;436        }
;;;437        else
;;;438        {
;;;439          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  f04f0c37          MOV      r12,#0x37
00000c  461c              MOV      r4,r3                 ;429
00000e  e00f              B        |L4.48|
                  |L4.16|
000010  ebb57f10          CMP      r5,r0,LSR #28         ;433
000014  d902              BLS      |L4.28|
000016  eb077610          ADD      r6,r7,r0,LSR #28      ;435
00001a  e001              B        |L4.32|
                  |L4.28|
00001c  eb0c7610          ADD      r6,r12,r0,LSR #28
                  |L4.32|
000020  f8016013          STRB     r6,[r1,r3,LSL #1]
;;;440        }
;;;441        
;;;442        value = value << 4;
;;;443        
;;;444        pbuf[ 2* idx + 1] = 0;
000024  eb010643          ADD      r6,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;442
00002a  1c5b              ADDS     r3,r3,#1              ;431
00002c  7074              STRB     r4,[r6,#1]
00002e  b2db              UXTB     r3,r3                 ;431
                  |L4.48|
000030  4293              CMP      r3,r2                 ;431
000032  d3ed              BCC      |L4.16|
;;;445      }
;;;446    }
000034  bdf0              POP      {r4-r7,pc}
;;;447    #ifdef STM32F10X_CL
                          ENDP


                          AREA ||i.JoyState||, CODE, READONLY, ALIGN=1

                  JoyState PROC
;;;369    *******************************************************************************/
;;;370    uint8_t JoyState(void)
000000  2000              MOVS     r0,#0
;;;371    {
;;;372      {
;;;373        return 0;
;;;374      }
;;;375      
;;;376    
;;;377    }
000002  4770              BX       lr
;;;378    
                          ENDP


                          AREA ||i.Joystick_Send||, CODE, READONLY, ALIGN=1

                  Joystick_Send PROC
;;;385    *******************************************************************************/
;;;386    void Joystick_Send(uint8_t Keys)
000000  4770              BX       lr
;;;387    {
;;;388    }
;;;389    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;211    *******************************************************************************/
;;;212    void Leave_LowPowerMode(void)
000000  b510              PUSH     {r4,lr}
;;;213    {
;;;214      DEVICE_INFO *pInfo = &Device_Info;
000002  4c12              LDR      r4,|L7.76|
;;;215    
;;;216      /* Wait till HSE is ready */
;;;217      HSEStartUpStatus = RCC_WaitForHSEStartUp();
000004  f7fffffe          BL       RCC_WaitForHSEStartUp
000008  4911              LDR      r1,|L7.80|
00000a  7008              STRB     r0,[r1,#0]
;;;218    
;;;219      /* Enable HSE */
;;;220      RCC_HSEConfig(RCC_HSE_ON);
00000c  f44f3080          MOV      r0,#0x10000
000010  f7fffffe          BL       RCC_HSEConfig
                  |L7.20|
;;;221    
;;;222      /* Wait till HSE is ready */
;;;223      while (RCC_GetFlagStatus(RCC_FLAG_HSERDY) == RESET)
000014  2031              MOVS     r0,#0x31
000016  f7fffffe          BL       RCC_GetFlagStatus
00001a  2800              CMP      r0,#0
00001c  d0fa              BEQ      |L7.20|
;;;224      {}
;;;225      
;;;226    #ifdef  STM32F10X_CL
;;;227      /* Enable PLL2 */
;;;228      RCC_PLL2Cmd(ENABLE);  
;;;229    
;;;230      /* Wait till PLL2 is ready */
;;;231      while (RCC_GetFlagStatus(RCC_FLAG_PLL2RDY) == RESET)
;;;232      {}
;;;233    #endif /* STM32F10X_CL */
;;;234      
;;;235      /* Enable PLL1 */
;;;236      RCC_PLLCmd(ENABLE);
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       RCC_PLLCmd
                  |L7.36|
;;;237    
;;;238      /* Wait till PLL1 is ready */
;;;239      while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000024  2039              MOVS     r0,#0x39
000026  f7fffffe          BL       RCC_GetFlagStatus
00002a  2800              CMP      r0,#0
00002c  d0fa              BEQ      |L7.36|
;;;240      {}
;;;241    
;;;242      /* Select PLL as system clock source */
;;;243      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       RCC_SYSCLKConfig
                  |L7.52|
;;;244    
;;;245      /* Wait till PLL is used as system clock source */
;;;246      while (RCC_GetSYSCLKSource() != RCC_CFGR_SWS_PLL)
000034  f7fffffe          BL       RCC_GetSYSCLKSource
000038  2808              CMP      r0,#8
00003a  d1fb              BNE      |L7.52|
;;;247      {}  
;;;248      
;;;249      /* Set the device state to the correct state */
;;;250      if (pInfo->Current_Configuration != 0)
00003c  7aa1              LDRB     r1,[r4,#0xa]
;;;251      {
;;;252        /* Device configured */
;;;253        bDeviceState = CONFIGURED;
00003e  4805              LDR      r0,|L7.84|
000040  b109              CBZ      r1,|L7.70|
000042  2105              MOVS     r1,#5
000044  e000              B        |L7.72|
                  |L7.70|
;;;254      }
;;;255      else
;;;256      {
;;;257        bDeviceState = ATTACHED;
000046  2101              MOVS     r1,#1
                  |L7.72|
000048  6001              STR      r1,[r0,#0]            ;253  ; bDeviceState
;;;258      }
;;;259    }
00004a  bd10              POP      {r4,pc}
;;;260    
                          ENDP

                  |L7.76|
                          DCD      Device_Info
                  |L7.80|
                          DCD      ||.data||
                  |L7.84|
                          DCD      bDeviceState

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;55     *******************************************************************************/
;;;56     void Set_System(void)
000000  b508              PUSH     {r3,lr}
;;;57     {
;;;58     #if !defined(STM32F10X_CL) && !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD)&& !defined(STM32L1XX_MD_PLUS)
;;;59       GPIO_InitTypeDef  GPIO_InitStructure;
;;;60     #endif /* STM32F10X_CL && STM32L1XX_XD */
;;;61       
;;;62     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;63       GPIO_InitTypeDef  GPIO_InitStructure;
;;;64     #endif /* USB_USE_EXTERNAL_PULLUP */
;;;65       
;;;66       /*!< At this stage the microcontroller clock setting is already configured, 
;;;67            this is done through SystemInit() function which is called from startup
;;;68            file (startup_stm32xxx.s) before to branch to application main.
;;;69            To reconfigure the default setting of SystemInit() function, refer to
;;;70            system_stm32xxx.c file
;;;71          */ 
;;;72     
;;;73       /* Enable the PWR clock */
;;;74       RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  0708              LSLS     r0,r1,#28
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;75     
;;;76     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;77       /* Enable the SYSCFG module clock (used for the USB disconnect feature) */
;;;78       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
;;;79     #endif /* STM32L1XX_XD */   
;;;80     
;;;81       /* Set all the GPIOs to AIN *************************************************/
;;;82      #if !defined(STM32L1XX_MD) || !defined(STM32L1XX_HD) || !defined(STM32L1XX_MD_PLUS)
;;;83       GPIO_AINConfig();
00000a  f7fffffe          BL       GPIO_AINConfig
;;;84     #endif /* STM32L1XX_XD */     
;;;85     
;;;86       /* Conifgure disconnect IO **************************************************/
;;;87     #if !defined(STM32F10X_CL) && !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS)
;;;88       /* Enable the USB disconnect GPIO clock */
;;;89       RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
00000e  2101              MOVS     r1,#1
000010  2008              MOVS     r0,#8
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;90     
;;;91       /* USB_DISCONNECT used as USB pull-up */
;;;92       GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
000016  f44f4080          MOV      r0,#0x4000
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;93       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001e  2003              MOVS     r0,#3
000020  f88d0002          STRB     r0,[sp,#2]
;;;94       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000024  2014              MOVS     r0,#0x14
000026  f88d0003          STRB     r0,[sp,#3]
;;;95       GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4801              LDR      r0,|L8.52|
00002e  f7fffffe          BL       GPIO_Init
;;;96     #endif /* STM32F10X_CL && STM32L1XX_XD */
;;;97     
;;;98     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;99       /* Enable the USB disconnect GPIO clock */
;;;100      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;101    
;;;102      /* USB_DISCONNECT used as USB pull-up */
;;;103      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;104      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;105      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;106      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;107      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;108      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;109    #endif /* USB_USE_EXTERNAL_PULLUP */
;;;110    
;;;111    
;;;112    }
000032  bd08              POP      {r3,pc}
;;;113    
                          ENDP

                  |L8.52|
                          DCD      0x40010c00

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;120    *******************************************************************************/
;;;121    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;124      /* Enable USB clock */
;;;125      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;126    #elif defined(STM32F10X_CL)
;;;127      /* Select USBCLK source */
;;;128      RCC_OTGFSCLKConfig(RCC_OTGFSCLKSource_PLLVCO_Div3);
;;;129    
;;;130      /* Enable the USB clock */ 
;;;131      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_OTG_FS, ENABLE) ;
;;;132    #else
;;;133      /* Select USBCLK source */
;;;134      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;135      
;;;136      /* Enable the USB clock */
;;;137      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;138    #endif /* STM32L1XX_XD */
;;;139    }
;;;140    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;328    *******************************************************************************/
;;;329    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;330    {
;;;331    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;332      if (NewState != DISABLE)
;;;333      {
;;;334        STM32L15_USB_CONNECT;
;;;335      }
;;;336      else
;;;337      {
;;;338        STM32L15_USB_DISCONNECT;
;;;339      }  
;;;340      
;;;341    #elif defined(USE_STM3210C_EVAL)  
;;;342      if (NewState != DISABLE)
;;;343      {
;;;344        USB_DevConnect();
;;;345      }
;;;346      else
;;;347      {
;;;348        USB_DevDisconnect();
;;;349      }
;;;350      
;;;351    #else /* USE_STM3210B_EVAL or USE_STM3210E_EVAL */
;;;352      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;353      {
;;;354        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000004  f44f4180          MOV      r1,#0x4000
;;;355      }
;;;356      else
;;;357      {
;;;358        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L10.16|
00000c  f7ffbffe          B.W      GPIO_ResetBits
                  |L10.16|
000010  f7ffbffe          B.W      GPIO_SetBits
;;;359      }
;;;360    #endif
;;;361    }
;;;362    
                          ENDP

                  |L10.20|
                          DCD      0x40010c00

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;267    *******************************************************************************/
;;;268    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;269    {
;;;270      NVIC_InitTypeDef NVIC_InitStructure;
;;;271    
;;;272      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;273      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;274    
;;;275    #ifdef STM32F10X_CL
;;;276      /* Enable the USB Interrupts */
;;;277      NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
;;;278      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;279      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;280      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;281      NVIC_Init(&NVIC_InitStructure);
;;;282    
;;;283      /* Enable the USB Wake-up interrupt */
;;;284      NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_WKUP_IRQn;
;;;285      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;286      NVIC_Init(&NVIC_InitStructure);  
;;;287      
;;;288    #elif defined(STM32L1XX_MD)|| defined(STM32L1XX_HD) || defined(STM32L1XX_MD_PLUS)
;;;289      /* Enable the USB interrupt */
;;;290      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;291      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;292      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;293      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;294      NVIC_Init(&NVIC_InitStructure);
;;;295    
;;;296      /* Enable the USB Wake-up interrupt */
;;;297      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
;;;298      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;299      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;300      NVIC_Init(&NVIC_InitStructure);
;;;301      
;;;302    #else /* USE_STM3210B_EVAL or USE_STM3210E_EVAL */
;;;303      /* Enable the USB interrupt */
;;;304      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;305      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;306      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2000              MOVS     r0,#0
000018  f88d0002          STRB     r0,[sp,#2]
;;;307      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2401              MOVS     r4,#1
00001e  f88d4003          STRB     r4,[sp,#3]
;;;308      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;309      
;;;310      /* Enable the USB Wake-up interrupt */
;;;311      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;312      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;313      NVIC_Init(&NVIC_InitStructure);   
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       NVIC_Init
;;;314    #endif /* STM32F10X_CL */
;;;315    
;;;316      /* Enable the Key EXTI line Interrupt */
;;;317    //  NVIC_InitStructure.NVIC_IRQChannel = KEY_BUTTON_EXTI_IRQn;
;;;318    //  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;319    //  NVIC_Init(&NVIC_InitStructure);
;;;320    }
000038  bd38              POP      {r3-r5,pc}
;;;321    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 114 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 128
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
