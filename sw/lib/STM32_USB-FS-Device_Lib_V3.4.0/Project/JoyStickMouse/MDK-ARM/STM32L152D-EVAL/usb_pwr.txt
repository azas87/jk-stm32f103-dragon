; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\STM32L152D-EVAL\usb_pwr.o --asm_dir=.\STM32L152D-EVAL\ --list_dir=.\STM32L152D-EVAL\ --depend=.\STM32L152D-EVAL\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152D_EVAL -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD -DUSE_STM3210E_EVAL ..\src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;92     *******************************************************************************/
;;;93     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;94     {
;;;95     #ifndef STM32F10X_CL
;;;96       /* disable all interrupts and force USB reset */
;;;97       _SetCNTR(CNTR_FRES);
000002  4c06              LDR      r4,|L1.28|
000004  2001              MOVS     r0,#1
000006  6020              STR      r0,[r4,#0]
;;;98       /* clear interrupt status register */
;;;99       _SetISTR(0);
000008  1d21              ADDS     r1,r4,#4
00000a  2000              MOVS     r0,#0
00000c  6008              STR      r0,[r1,#0]
;;;100      /* Disable the Pull-Up*/
;;;101      USB_Cable_Config(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Config
;;;102      /* switch-off device */
;;;103      _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  6020              STR      r0,[r4,#0]
;;;104      /* sw variables reset */
;;;105      /* ... */
;;;106    #endif /* STM32F10X_CL */
;;;107    
;;;108      return USB_SUCCESS;
000016  2000              MOVS     r0,#0
;;;109    }
000018  bd10              POP      {r4,pc}
;;;110    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;60     *******************************************************************************/
;;;61     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;62     {
;;;63     #ifndef STM32F10X_CL
;;;64       uint16_t wRegVal;
;;;65     
;;;66       /*** cable plugged-in ? ***/
;;;67       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;68     
;;;69       /*** CNTR_PWDN = 0 ***/
;;;70       wRegVal = CNTR_FRES;
;;;71       _SetCNTR(wRegVal);
000008  4806              LDR      r0,|L2.36|
00000a  2101              MOVS     r1,#1                 ;70
00000c  6001              STR      r1,[r0,#0]
;;;72     
;;;73       /*** CNTR_FRES = 0 ***/
;;;74       wInterrupt_Mask = 0;
00000e  2100              MOVS     r1,#0
000010  4a05              LDR      r2,|L2.40|
;;;75       _SetCNTR(wInterrupt_Mask);
000012  6001              STR      r1,[r0,#0]
;;;76       /*** Clear pending interrupts ***/
;;;77       _SetISTR(0);
000014  1d03              ADDS     r3,r0,#4
000016  6019              STR      r1,[r3,#0]
;;;78       /*** Set interrupt mask ***/
;;;79       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000018  f44f51e0          MOV      r1,#0x1c00
00001c  8011              STRH     r1,[r2,#0]
;;;80       _SetCNTR(wInterrupt_Mask);
00001e  6001              STR      r1,[r0,#0]
;;;81     #endif /* STM32F10X_CL */
;;;82     
;;;83       return USB_SUCCESS;
000020  2000              MOVS     r0,#0
;;;84     }
000022  bd10              POP      {r4,pc}
;;;85     
                          ENDP

                  |L2.36|
                          DCD      0x40005c40
                  |L2.40|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;206    *******************************************************************************/
;;;207    void Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;208    {
;;;209    #ifndef STM32F10X_CL
;;;210      uint16_t wCNTR;
;;;211    #endif /* STM32F10X_CL */
;;;212    
;;;213      if (eResumeSetVal != RESUME_ESOF)
;;;214        ResumeS.eState = eResumeSetVal;
000002  4c1c              LDR      r4,|L3.116|
000004  2807              CMP      r0,#7                 ;213
000006  d000              BEQ      |L3.10|
000008  7020              STRB     r0,[r4,#0]
                  |L3.10|
;;;215    
;;;216      switch (ResumeS.eState)
00000a  7821              LDRB     r1,[r4,#0]  ; ResumeS
;;;217      {
;;;218        case RESUME_EXTERNAL:
;;;219          Resume_Init();
;;;220          ResumeS.eState = RESUME_OFF;
00000c  2606              MOVS     r6,#6
;;;221          break;
;;;222        case RESUME_INTERNAL:
;;;223          Resume_Init();
;;;224          ResumeS.eState = RESUME_START;
00000e  2504              MOVS     r5,#4
;;;225          break;
;;;226        case RESUME_LATER:
;;;227          ResumeS.bESOFcnt = 2;
;;;228          ResumeS.eState = RESUME_WAIT;
;;;229          break;
;;;230        case RESUME_WAIT:
;;;231          ResumeS.bESOFcnt--;
;;;232          if (ResumeS.bESOFcnt == 0)
;;;233            ResumeS.eState = RESUME_START;
;;;234          break;
;;;235        case RESUME_START:
;;;236         #ifdef STM32F10X_CL
;;;237          OTGD_FS_SetRemoteWakeup();
;;;238         #else 
;;;239          wCNTR = _GetCNTR();
000010  4819              LDR      r0,|L3.120|
000012  2906              CMP      r1,#6                 ;216
000014  d22c              BCS      |L3.112|
000016  e8dff001          TBB      [pc,r1]               ;216
00001a  0306              DCB      0x03,0x06
00001c  090e1620          DCB      0x09,0x0e,0x16,0x20
000020  f7fffffe          BL       Resume_Init
000024  e024              B        |L3.112|
000026  f7fffffe          BL       Resume_Init
00002a  e00a              B        |L3.66|
00002c  2002              MOVS     r0,#2                 ;227
00002e  7060              STRB     r0,[r4,#1]            ;227
000030  2003              MOVS     r0,#3                 ;228
000032  7020              STRB     r0,[r4,#0]            ;228
                  |L3.52|
;;;240          wCNTR |= CNTR_RESUME;
;;;241          _SetCNTR(wCNTR);
;;;242         #endif /* STM32F10X_CL */
;;;243          ResumeS.eState = RESUME_ON;
;;;244          ResumeS.bESOFcnt = 10;
;;;245          break;
;;;246        case RESUME_ON:
;;;247        #ifndef STM32F10X_CL      
;;;248          ResumeS.bESOFcnt--;
;;;249          if (ResumeS.bESOFcnt == 0)
;;;250          {
;;;251         #endif /* STM32F10X_CL */    
;;;252           #ifdef STM32F10X_CL
;;;253            OTGD_FS_ResetRemoteWakeup();
;;;254           #else
;;;255            wCNTR = _GetCNTR();
;;;256            wCNTR &= (~CNTR_RESUME);
;;;257            _SetCNTR(wCNTR);
;;;258           #endif /* STM32F10X_CL */
;;;259            ResumeS.eState = RESUME_OFF;
;;;260         #ifndef STM32F10X_CL
;;;261          }
;;;262         #endif /* STM32F10X_CL */
;;;263          break;
;;;264        case RESUME_OFF:
;;;265        case RESUME_ESOF:
;;;266        default:
;;;267          ResumeS.eState = RESUME_OFF;
;;;268          break;
;;;269      }
;;;270    }
000034  bd70              POP      {r4-r6,pc}
000036  7860              LDRB     r0,[r4,#1]            ;231  ; ResumeS
000038  1e40              SUBS     r0,r0,#1              ;231
00003a  7060              STRB     r0,[r4,#1]            ;231
00003c  7860              LDRB     r0,[r4,#1]            ;232  ; ResumeS
00003e  2800              CMP      r0,#0                 ;232
000040  d1f8              BNE      |L3.52|
                  |L3.66|
000042  7025              STRB     r5,[r4,#0]            ;233
000044  bd70              POP      {r4-r6,pc}
000046  6801              LDR      r1,[r0,#0]            ;239
000048  b289              UXTH     r1,r1                 ;239
00004a  f0410110          ORR      r1,r1,#0x10           ;240
00004e  6001              STR      r1,[r0,#0]            ;241
000050  2005              MOVS     r0,#5                 ;243
000052  7020              STRB     r0,[r4,#0]            ;243
000054  200a              MOVS     r0,#0xa               ;244
000056  7060              STRB     r0,[r4,#1]            ;244
                  |L3.88|
000058  bd70              POP      {r4-r6,pc}
00005a  7861              LDRB     r1,[r4,#1]            ;248  ; ResumeS
00005c  1e49              SUBS     r1,r1,#1              ;248
00005e  7061              STRB     r1,[r4,#1]            ;248
000060  7861              LDRB     r1,[r4,#1]            ;249  ; ResumeS
000062  2900              CMP      r1,#0                 ;249
000064  d1f8              BNE      |L3.88|
000066  6801              LDR      r1,[r0,#0]            ;255
000068  b289              UXTH     r1,r1                 ;255
00006a  f0210110          BIC      r1,r1,#0x10           ;256
00006e  6001              STR      r1,[r0,#0]            ;257
                  |L3.112|
000070  7026              STRB     r6,[r4,#0]            ;267
000072  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP

                  |L3.116|
                          DCD      ||area_number.10||
                  |L3.120|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;158    *******************************************************************************/
;;;159    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;160    {
;;;161    #ifndef STM32F10X_CL
;;;162      uint16_t wCNTR;
;;;163    #endif /* STM32F10X_CL */  
;;;164    
;;;165      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;166      /* restart the clocks */
;;;167      /* ...  */
;;;168    
;;;169    #ifndef STM32F10X_CL
;;;170      /* CNTR_LPMODE = 0 */
;;;171      wCNTR = _GetCNTR();
000002  4c06              LDR      r4,|L4.28|
000004  6820              LDR      r0,[r4,#0]
000006  b280              UXTH     r0,r0
;;;172      wCNTR &= (~CNTR_LPMODE);
000008  f0200004          BIC      r0,r0,#4
;;;173      _SetCNTR(wCNTR);
00000c  6020              STR      r0,[r4,#0]
;;;174    #endif /* STM32F10X_CL */
;;;175    
;;;176    #ifdef STM32F10X_CL
;;;177      /* Ungate the PHY and AHB USB clocks  */
;;;178      _OTGD_FS_UNGATE_PHYCLK;
;;;179    #endif /* STM32F10X_CL */    
;;;180      
;;;181      /* restore full power */
;;;182      /* ... on connected devices */
;;;183      Leave_LowPowerMode();
00000e  f7fffffe          BL       Leave_LowPowerMode
;;;184    
;;;185    #ifndef STM32F10X_CL
;;;186      /* reset FSUSP bit */
;;;187      _SetCNTR(IMR_MSK);
000012  f44f403f          MOV      r0,#0xbf00
000016  6020              STR      r0,[r4,#0]
;;;188    #endif /* STM32F10X_CL */
;;;189    
;;;190      /* reverse suspend preparation */
;;;191      /* ... */ 
;;;192    
;;;193    }
000018  bd10              POP      {r4,pc}
;;;194    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;117    *******************************************************************************/
;;;118    void Suspend(void)
000000  4806              LDR      r0,|L5.28|
;;;119    {
;;;120    #ifndef STM32F10X_CL
;;;121      uint16_t wCNTR;
;;;122      /* suspend preparation */
;;;123      /* ... */
;;;124    
;;;125      /* macrocell enters suspend mode */
;;;126      wCNTR = _GetCNTR();
000002  6801              LDR      r1,[r0,#0]
000004  b289              UXTH     r1,r1
;;;127      wCNTR |= CNTR_FSUSP;
000006  f0410108          ORR      r1,r1,#8
;;;128      _SetCNTR(wCNTR);
00000a  6001              STR      r1,[r0,#0]
;;;129    
;;;130      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;131      /* power reduction */
;;;132      /* ... on connected devices */
;;;133    
;;;134    
;;;135      /* force low-power mode in the macrocell */
;;;136      wCNTR = _GetCNTR();
00000c  6801              LDR      r1,[r0,#0]
00000e  b289              UXTH     r1,r1
;;;137      wCNTR |= CNTR_LPMODE;
000010  f0410104          ORR      r1,r1,#4
;;;138      _SetCNTR(wCNTR);
000014  6001              STR      r1,[r0,#0]
;;;139    #endif /* STM32F10X_CL */
;;;140    
;;;141    #ifdef STM32F10X_CL
;;;142      /* Gate the PHY and AHB USB clocks  */
;;;143      _OTGD_FS_GATE_PHYCLK;
;;;144    #endif /* STM32F10X_CL */
;;;145    
;;;146      /* switch-off the clocks */
;;;147      /* ... */
;;;148      Enter_LowPowerMode();
000016  f7ffbffe          B.W      Enter_LowPowerMode
;;;149    
;;;150    }
;;;151    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40005c40

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000

                          AREA ||area_number.9||, DATA, ALIGN=0

                          EXPORTAS ||area_number.9||, ||.data||
                  fSuspendEnabled
000000  01                DCB      0x01

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  ResumeS
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_pwr.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 114 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 128
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
